<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="notes.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <title>SEM2 DBMS Unit-3</title>
</head>
<body>
    
    <nav class="nav-container">
        <div class="text_logo">
            <h2 class="logo">MCA_<span class="notes_text"> Notes</span></h2>
        </div>

        <ul class="list">
            <a href="/index.html"><li class="listno list-diplay">Home</li></a>
            <li class="listno list-diplay">About</li>
            <li class="listno list-diplay">Contact</li>
            <li><span class="download list-diplay" id="download">Download</span></li>
            <li class="toggle"><i class="fa-solid fa-bars fa-lg toggle-btn"></i></li>
        </ul>

        
    </nav>
    <div class="dropDown">
        <ul class="drop-list">
            <a href="/index.html"><li class="listno ">Home</li></a>
            <li class="listno ">About</li>
            <li class="listno">Contact</li>
            <li><span class="download " id="download">Download</span></li></ul>
    </div>

    <!-- .................................................................... -->
    
    <div class="noteContainer">
    
    <!------------------------ paste code here   ---------------------------------- -->
    <div style="margin: 5px 0;">
        <h1>Query Processing in DBMS</h1>
        <p>Query Processing is the activity performed in extracting data from the database. In query processing, it takes various steps for fetching the data from the database. The steps involved are:</p>
        <ol>
          <li>Parsing and translation</li>
          <li>Optimization</li>
          <li>Evaluation</li>
        </ol>
        <p>The query processing works in the following way:</p>
        <h2>Parsing and Translation</h2>
        <p>As query processing includes certain activities for data retrieval. Initially, the given user queries get translated in high-level database languages such as SQL. It gets translated into expressions that can be further used at the physical level of the file system. After this, the actual evaluation of the queries and a variety of query -optimizing transformations and takes place. Thus before processing a query, a computer system needs to translate the query into a human-readable and understandable language. Consequently, SQL or Structured Query Language is the best suitable choice for humans. But, it is not perfectly suitable for the internal representation of the query to the system. Relational algebra is well suited for the internal representation of a query. The translation process in query processing is similar to the parser of a query. When a user executes any query, for generating the internal form of the query, the parser in the system checks the syntax of the query, verifies the name of the relation in the database, the tuple, and finally the required attribute value. The parser creates a tree of the query, known as 'parse-tree.' Further, translate it into the form of relational algebra. With this, it evenly replaces all the use of the views when used in the query.</p>
        <p>Thus, we can understand the working of a query processing in the below-described diagram:</p>
        <p>&nbsp;</p>
        <p>Suppose a user executes a query. As we have learned that there are various methods of extracting the data from the database. In SQL, a user wants to fetch the records of the employees whose salary is greater than or equal to 10000. For doing this, the following query is undertaken:</p>
        <p><strong>select emp_name from Employee where salary&gt;10000;</strong></p>
        <p>Thus, to make the system understand the user query, it needs to be translated in the form of relational algebra. We can bring this query in the relational algebra form as:</p>
        <p>○ <strong>&sigma;</strong><strong>salary&gt;10000 </strong><strong>(&pi;</strong><strong>salary </strong><strong>(Employee))</strong></p>
        <p>○ <strong>&pi;</strong><strong>salary </strong><strong>(&sigma;</strong><strong>salary&gt;10000 </strong><strong>(Employee))</strong></p>
        <p>After translating the given query, we can execute each relational algebra operation by using different algorithms. So, in this way, a query processing begins its working.</p>
        <h2>Evaluation</h2>
        <p>For this, with addition to the relational algebra translation, it is required to annotate the translated relational algebra expression with the instructions used for specifying and evaluating each operation. Thus, after translating the user query, the system executes a query evaluation plan.</p>
        <h3>Query Evaluation Plan</h3>
        <p>○ In order to fully evaluate a query, the system needs to construct a query evaluation</p>
        <p>plan.</p>
        <p>○ The annotations in the evaluation plan may refer to the algorithms to be used for the particular index or the specific operations.</p>
        <p>○ Such relational algebra with annotations is referred to as <strong>Evaluation Primitives</strong>. The evaluation primitives carry the instructions needed for the evaluation of the</p>
        <p>operation.</p>
        <p>○ Thus, a query evaluation plan defines a sequence of primitive operations used for evaluating a query. The query evaluation plan is also referred to as <strong>the query </strong></p>
        <p><strong>execution plan</strong>.</p>
        <p>○ A <strong>query execution engine </strong>is responsible for generating the output of the given query. It takes the query execution plan, executes it, and finally makes the output for the user query.</p>
        <h2>Optimization</h2>
        <p>○ The cost of the query evaluation can vary for different types of queries. Although the system is responsible for constructing the evaluation plan, the user does need not to write their query efficiently.</p>
        <p>○ Usually, a database system generates an efficient query evaluation plan, which minimizes its cost. This type of task performed by the database system and is known as Query Optimization.</p>
        <p>○ For optimizing a query, the query optimizer should have an estimated cost analysis of each operation. It is because the overall operation cost depends on the memory allocations to several operations, execution costs, and so on.</p>
        <p>Finally, after selecting an evaluation plan, the system evaluates the query and produces the output of the query.</p>
        <h1>Estimating Query Cost</h1>
        <p>In the previous section, we understood about Query processing steps and evaluation plan. Though a system can create multiple plans for a query, the chosen method should be the best of all. It can be done by comparing each possible plan in terms of their estimated cost. For calculating the net estimated cost of any plan, the cost of each operation within a plan should be determined and combined to get the net estimated cost of the query evaluation plan.</p>
        <p>The cost estimation of a query evaluation plan is calculated in terms of various resources that include:</p>
        <p>○ Number of disk accesses</p>
        <p>○ Execution time taken by the CPU to execute a query</p>
        <p>○ Communication costs in distributed or parallel database systems.</p>
        <p>To estimate the cost of a query evaluation plan, we use the number of blocks transferred from the disk, and the number of disks seeks. Suppose the disk has an average block access time of t<sub>s </sub>seconds and takes an average of t<sub>T </sub>seconds to transfer x data blocks. The block access time is the sum of disk seeks time and rotational latency. It performs S seeks than the time taken will be <strong>b*t</strong><strong><sub>T </sub></strong><strong>+ S*t</strong><strong><sub>S </sub></strong>seconds. If t<sub>T</sub>=0.1 ms, t<sub>S </sub>=4 ms, the block size is 4 KB, and its transfer rate is 40 MB per second. With this, we can easily calculate the estimated cost of the given query evaluation plan.</p>
        <p>Generally, for estimating the cost, we consider the worst case that could happen. The users assume that initially, the data is read from the disk only. But there must be a chance that the information is already present in the main memory. However, the users usually ignore this effect, and due to this, the actual cost of execution comes out less than the estimated value.</p>
        <p>The response time, i.e., the time required to execute the plan, could be used for estimating the cost of the query evaluation plan. But due to the following reasons, it becomes difficult to calculate the response time without actually executing the query evaluation plan:</p>
        <p>○ When the query begins its execution, the response time becomes dependent on the contents stored in the buffer. But this information is difficult to retrieve when the query is in optimized mode, or it is not available also.</p>
        <p>○ When a system with multiple disks is present, the response time depends on an interrogation that in "what way accesses are distributed among the disks?". It is difficult to estimate without having detailed knowledge of the data layout present over the disk.</p>
        <p>○ Consequently, instead of minimizing the response time for any query evaluation plan, the optimizers finds it better to reduce the total <strong>resource consumption </strong>of the query plan. Thus to estimate the cost of a query evaluation plan, it is good to minimize the resources used for accessing the disk or use of the extra</p>
        <p>resources.</p>
        <h1>Selection Operation in Query Processing</h1>
        <p>In the previous section, we understood that estimating the cost of a query plan should be done by measuring the total resource consumption.</p>
        <p>In this section, we will understand how the selection operation is performed in the query execution plan.</p>
        <p>Generally, the selection operation is performed by the file scan. <strong>File scans </strong>are the search algorithms that are used for locating and accessing the data. It is the lowest-level operator used in query processing.</p>
        <p>Let's see how selection using a file scan is performed.</p>
        <h2>Selection using File scans and Indices</h2>
        <p>In RDBMS or relational database systems, the file scan reads a relation only if the whole relation is stored in one file only. When the selection operation is performed on a relation whose tuples are stored in one file, it uses the following algorithms:</p>
        <p>○ <strong>Linear Search: </strong>In a linear search, the system scans each record to test whether satisfying the given selection condition. For accessing the first block of a file, it needs an initial seek. If the blocks in the file are not stored in contiguous order, then it needs some extra seeks. However, linear search is the slowest algorithm used for searching, but it is applicable in all types of cases. This algorithm does not care about the nature of selection, availability of indices, or the file sequence.</p>
        <p>But other algorithms are not applicable in all types of cases.</p>
        <h2>Selection Operation with Indexes</h2>
        <p>The index-based search algorithms are known as <strong>Index scans</strong>. Such index structures are known as <strong>access paths</strong>. These paths allow locating and accessing the data in the file. There are following algorithms that use the index in query processing:</p>
        <p>○ <strong>Primary index, equality on a key: </strong>We use the index to retrieve a single record that satisfies the equality condition for making the selection. The equality comparison is performed on the key attribute carrying a primary key.</p>
        <p>○ <strong>Primary index, equality on nonkey: </strong>The difference between equality on key and nonkey is that in this, we can fetch multiple records. We can fetch multiple records through a primary key when the selection criteria specify the equality comparison on a nonkey.</p>
        <p>○ <strong>Secondary index, equality on key or nonkey: </strong>The selection that specifies an equality condition can use the secondary index. Using secondary index strategy, we can either retrieve a single record when equality is on key or multiple records when the equality condition is on nonkey. When retrieving a single record, the time cost is equal to the primary index. In the case of multiple records, they may reside on different blocks. This results in one I/O operation per fetched record, and each I/O operation requires a seek and a block transfer.</p>
        <h2>Selection Operations with Comparisons</h2>
        <p>For making any selection on the basis of a comparison in a relation, we can proceed it either by using the linear search or via indices in the following ways:</p>
        <p>○ <strong>Primary index, comparison: </strong>When the selection condition given by the user is a comparison, then we use a primary ordered index, such as the primary B<sup>+</sup>-tree index. <strong>For example</strong>, when A attribute of a relation R compared with a given value v as A&gt;v, then we use a primary index on A to directly retrieve the tuples. The file scan starts its search from the beginning till the end and outputs all those tuples that satisfy the given selection condition.</p>
        <p>○ <strong>Secondary index, comparison: </strong>The secondary ordered index is used for satisfying the selection operation that involves &lt;, &gt;, &le;, or &ge; In this, the files scan searches the blocks of the lowest-level index.</p>
        <p><strong>(&lt; &le;): </strong>In this case, it scans from the smallest value up to the given value v.</p>
        <p><strong>(&gt;, &ge;): </strong>In this case, it scans from the given value v up to the maximum value. However, the use of the secondary index should be limited for selecting a few records. It is because such an index provides pointers to point each record, so users can easily fetch the record through the allocated pointers. Such retrieved records may require an I/O operation as records may be stored on different blocks of the file. So, if the number of fetched records is large, it becomes expensive with the secondary index.</p>
        <h2>Implementing Complex Selection Operations</h2>
        <p>Working on more complex selection involves three selection predicates known as Conjunction, Disjunction, and Negation.</p>
        <p><strong>Conjunction: </strong>A conjunctive selection is the selection having the form as: <strong>&sigma; </strong></p>
        <p><strong>&theta;1 &theta;2 &hellip; &theta;n </strong><strong>(r)</strong></p>
        <p>A conjunction is the intersection of all records that satisfies the above selection condition.</p>
        <p><strong>Disjunction: </strong>A disjunctive selection is the selection having the form as: <strong>&sigma; </strong></p>
        <p><strong>&theta;1 &theta;2 &hellip; &theta;n </strong><strong>(r)</strong></p>
        <p>A disjunction is the union of all records that satisfies the given selection condition <strong>&theta;</strong><strong><sub>i</sub></strong>.</p>
        <p><strong>Negation: </strong>The result of a selection <strong>&sigma;</strong><strong><sub>&not;&theta;</sub></strong><strong>(r) </strong>is the set of tuples of given relation r where the selection condition evaluates to false. But nulls are not present, and this set is only the set of tuples in relation r that are not in <strong>&sigma;</strong><strong><sub>&theta;</sub></strong><strong>(r)</strong>.</p>
        <p>Using these discussed selection predicates, we can implement the selection operations by using the following algorithms:</p>
        <p>○ <strong>Conjunctive selection using one index: </strong>In such type of selection operation implementation, we initially determine if any access path is available for an attribute. If found one, then algorithms based on the index will work better. Further completion of the selection operation is done by testing that each selected records satisfy the remaining simple conditions. The cost of the selected algorithm provides the cost of this algorithm.</p>
        <p>○ <strong>Conjunctive selection via Composite index: </strong>A composite index is the one that is provided on multiple attributes. Such an index may be present for some conjunctive selections. If the given selection operation proves true on the equality condition on two or more attributes and a composite index is present on these combined attribute fields, then directly search the index. Such type of</p>
        <p>index evaluates the suitable index algorithms.</p>
        <p>○ <strong>Conjunctive selection via the intersection of identifiers: </strong>This implementation involves record pointers or record identifiers. It uses indices with the record pointers on those fields which are involved in the individual selection condition.</p>
        <p>It scans each index for pointers to tuples satisfying the individual condition. Therefore, the intersection of all the retrieved pointers is the set of pointers to the tuples that satisfies the conjunctive condition. The algorithm uses these pointers to fetch the actual records. However, in absence of indices on each individual condition, it tests the retrieved records for the other remaining</p>
        <p>conditions.</p>
        <p>○ <strong>Disjunctive selection by the union of identifiers: </strong>This algorithm scans those entire indexes for pointers to tuples that satisfy the individual condition. But only if access paths are available on all disjunctive selection conditions. Therefore, the union of all fetched records provides pointers sets to all those tuples which satisfy or prove the disjunctive condition. Further, it makes use of pointers for fetching the actual records. Somehow, if the access path is not present for anyone condition, we need to use a linear search to find those tuples that satisfy the condition. Thus, it is good to use a linear search for determining such tests.</p>
        <h1><strong>Sorting</strong></h1>
        <p>It is the technique of storing the records in ascending or descending order of one or more columns. It is useful because, some of the queries will ask us to return sorted records, or in operations like joins will be more efficient in sorted records. All the records are by default sorted based on the primary key column. In addition, we can specify to sort the records based on other columns, as required. Two types of sorting methods are mainly used.</p>
        <p>Internal Sorting:</p>
        <table width="600">
          <tbody>
            <tr>
              <td width="23">
                <p>&nbsp;</p>
              </td>
              <td width="577">
                <p>&nbsp; Internal sorting, also known as in-memory sorting, is performed when all the data to be sorted can fit entirely in memory. The sorting operation takes place within the main memory, which is faster compared to accessing data from disk.</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>In internal sorting, the DBMS loads the entire dataset into memory and applies sorting algorithms such as quicksort, mergesort, or heapsort. These algorithms rearrange the data in a specific order based on the sort criteria, such as ascending or descending order of a column. Once the sorting is complete, the sorted data is available for further</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>processing or retrieval.</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>Internal sorting is typically faster than external sorting because it avoids the overhead of reading and writing data to disk. However, it is limited by the available memory size.</p>
                <p>If</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>the dataset is too large to fit entirely in memory, external sorting techniques must be employed.</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>External Sorting:</p>
        <table width="600">
          <tbody>
            <tr>
              <td rowspan="3" width="23">
                <p>&nbsp;</p>
              </td>
              <td width="577">
                <p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; External sorting, also known as disk-based sorting, is used when the dataset is</p>
              </td>
            </tr>
            <tr>
              <td width="577">
                <p>too large to fit in memory. The sorting operation involves reading and writing data</p>
              </td>
            </tr>
            <tr>
              <td width="577">
                <p>to and from disk multiple times.</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>In external sorting, the DBMS divides the dataset into smaller parts, known as runs, that</p>
                <p>can fit in memory. Each run is sorted individually using internal sorting algorithms applied to the portion of the dataset residing in memory. The sorted runs are then merged together using techniques such as merge sort or replacement selection to</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>generate the final sorted result.</p>
                <p>The merging process involves reading a portion of each run into memory, comparing the</p>
                <p>records, and writing the sorted output to disk. This process continues until all runs have</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>been merged into a single sorted result.</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>External sorting is slower compared to internal sorting due to the disk I/O operations involved. However, it allows sorting large datasets that cannot be accommodated in</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>memory alone.</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>The choice between internal sorting and external sorting depends on the available</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>memory size and the size of the dataset being sorted. DBMS optimizers consider these</p>
                <p>factors along with other statistics to determine the most efficient sorting strategy during query processing.</p>
              </td>
            </tr>
          </tbody>
        </table>
        <h2>External Sort-Merge Algorithm</h2>
        <p>Till now, we saw that sorting is an important term in any database system. It means arranging the data either in ascending or descending order. We use sorting not only for generating a sequenced output but also for satisfying conditions of various database algorithms. In query processing, the sorting method is used for performing various relational operations such as joins, etc. efficiently. But the need is to provide a sorted input value to the system. For sorting any relation, we have to build an index on the sort key and use that index for reading the relation in sorted order. However, using an index, we sort the relation logically, not physically. Thus, sorting is performed for cases that include:</p>
        <p><strong>Case 1: </strong>Relations that are having either small or medium size than main memory.</p>
        <p><strong>Case 2: </strong>Relations having a size larger than the memory size.</p>
        <p>In Case 1, the small or medium size relations do not exceed the size of the main memory. So, we can fit them in memory. So, we can use standard sorting methods such as quicksort, merge sort, etc., to do so.</p>
        <p>For Case 2, the standard algorithms do not work properly. Thus, for such relations whose size exceeds the memory size, we use the External Sort-Merge algorithm.</p>
        <p>The sorting of relations which do not fit in the memory because their size is larger than the memory size. Such type of sorting is known as <strong>External Sorting</strong>. As a result, the external-sort merge is the most suitable method used for external sorting.</p>
        <p>External Sort-Merge Algorithm</p>
        <p>Here, we will discuss the external-sort merge algorithm stages in detail:</p>
        <p>In the algorithm, M signifies the number of disk blocks available in the main memory buffer for sorting.</p>
        <p><strong>Stage 1: </strong>Initially, we create a number of sorted runs. Sort each of them. These runs contain only a few records of the relation.</p>
        <ol>
          <li>i = 0;</li>
          <li>repeat</li>
          <li><strong>read </strong>either M blocks or the rest <strong>of </strong>the relation <strong>having </strong>a smaller <strong>size</strong>;</li>
          <li>sort the in-memory part <strong>of </strong>the relation;</li>
          <li>write the sorted data <strong>to </strong>run file Ri;</li>
          <li>i =i+1;</li>
          <li>Until the <strong>end of </strong>the relation</li>
        </ol>
        <p>In Stage 1, we can see that we are performing the sorting operation on the disk blocks. After completing the steps of Stage 1, proceed to Stage 2.</p>
        <p><strong>Stage 2: </strong>In Stage 2, we merge the runs. Consider that total number of runs, i.e., N is less than M. So, we can allocate one block to each run and still have some space left to hold one block of output. We perform the operation as follows:</p>
        <ol>
          <li><strong>read </strong>one block <strong>of </strong>each <strong>of </strong>N files Ri <strong>into </strong>a buffer block in memory;</li>
          <li>repeat</li>
          <li><strong>select </strong>the <strong>first </strong>tuple among all buffer blocks (<strong>where </strong>selection <strong>is </strong>made</li>
        </ol>
        <p>in sorted <strong>order</strong>);</p>
        <ol start="4">
          <li>write the tuple <strong>to </strong>the <strong>output</strong>, and <strong>then delete </strong>it <strong>from </strong>the buffer block;</li>
          <li>if the buffer block <strong>of </strong>any run Ri <strong>is </strong>empty and not EOF(Ri)</li>
          <li><strong>then read </strong>the <strong>next </strong>block <strong>of </strong>Ri <strong>into </strong>the buffer block;</li>
          <li>Until all input buffer blocks are empty</li>
        </ol>
        <p>After completing Stage 2, we will get a sorted relation as an output. The output file is then buffered for minimizing the disk-write operations. As this algorithm merges N runs, that's why it is known as an <strong>N-way merge.</strong></p>
        <p>However, if the size of the relation is larger than the memory size, then either M or more runs will be generated in Stage 1. Also, it is not possible to allocate a single block for each run while processing Stage 2. In such a case, the merge operation process in multiple passes. As M-1 input buffer blocks have sufficient memory, each merge can easily hold M-1 runs as its input. So, the initial phase works in the following way:</p>
        <p>○ It merges the first M-1 runs for getting a single run for the next one.</p>
        <p>○ Similarly, it merges the next M-1 runs. This step continues until it processes all the initial runs. Here, the number of runs has a reduced M-1 value. Still, if this reduced value is greater than or equal to M, we need to create another pass. For this new pass, the input will be the runs created by the first pass.</p>
        <p>○ The work of each pass will be to reduce the number of runs by M-1 value. This job repeats as many times as needed until the number of runs is either less than or</p>
        <p>equal to M.</p>
        <p>○ Thus, a final pass produces the sorted output.</p>
        <h3>Example of External Merge-sort Algorithm</h3>
        <p>Let's understand the working of the external merge-sort algorithm and also analyze the cost of the external sorting with the help of an example.</p>
        <p>&nbsp;</p>
        <p>Suppose that for a relation R, we are performing the external sort-merge. In this, assume that only one block can hold one tuple, and the memory can hold at most three blocks. So, while processing Stage 2, i.e., the merge stage, it will use two blocks as input and one block for output.</p>
        <h3>Join</h3>
        <p>Join operation combines the relation R1 and R2 with respect to a condition. It is denoted by ⋈.</p>
        <p>The different types of join operation are as follows &minus;</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Theta join&nbsp;</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Equi join</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Natural join</p>
        <p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outer join &minus; It is further classified into following types &minus; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Left outer join. &nbsp;</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Right outer join &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Full outer join.</p>
        <h4>Theta join</h4>
        <p>If we join R1 and R2 other than the equal to condition then it is called theta join/ nonequi join.</p>
        <h5>Example</h5>
        <p>Consider R1 table</p>
        <table width="694">
          <tbody>
            <tr>
              <td width="185">
                <p><strong>RegNo</strong></p>
              </td>
              <td rowspan="2" width="107">
                <p>&nbsp;</p>
              </td>
              <td width="195">
                <p><strong>Branch</strong></p>
              </td>
              <td width="74">
                <p>&nbsp;</p>
              </td>
              <td width="126">
                <p><strong>Section</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="185">
                <p>&nbsp;</p>
              </td>
              <td width="195">
                <p>&nbsp;</p>
              </td>
              <td width="74">
                <p>&nbsp;</p>
              </td>
              <td width="126">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="185">
                <p>1</p>
              </td>
              <td width="107">
                <p>&nbsp;</p>
              </td>
              <td width="195">
                <p>CSE</p>
              </td>
              <td width="74">
                <p>A</p>
              </td>
              <td colspan="2" width="134">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="185">
                <p>2</p>
              </td>
              <td width="107">
                <p>&nbsp;</p>
              </td>
              <td width="195">
                <p>ECE</p>
              </td>
              <td width="74">
                <p>B</p>
              </td>
              <td colspan="2" width="134">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="185">
                <p>3</p>
              </td>
              <td width="107">
                <p>&nbsp;</p>
              </td>
              <td width="195">
                <p>CIVIL</p>
              </td>
              <td width="74">
                <p>A</p>
              </td>
              <td colspan="2" width="134">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="185">
                <p>4</p>
              </td>
              <td width="107">
                <p>&nbsp;</p>
              </td>
              <td width="195">
                <p>IT</p>
              </td>
              <td width="74">
                <p>B</p>
              </td>
              <td colspan="2" width="134">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="292">
                <p>5</p>
              </td>
              <td width="195">
                <p>IT</p>
              </td>
              <td width="74">
                <p>A</p>
              </td>
              <td colspan="2" width="134">
                <p>&nbsp;</p>
              </td>
            </tr>
          </tbody>
        </table>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table R2<sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sub>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</h5>
        <table width="694">
          <tbody>
            <tr>
              <td rowspan="3" width="393">
                <p>&nbsp;</p>
              </td>
              <td rowspan="3" width="93">
                <p>&nbsp;</p>
              </td>
              <td width="208">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="208">
                <p><strong>RegNo</strong></p>
              </td>
            </tr>
            <tr>
              <td width="208">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="393">
                <p>Bhanu &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</p>
              </td>
              <td width="93">
                <p>2</p>
              </td>
              <td width="208">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="393">
                <p>Priya &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</p>
              </td>
              <td width="93">
                <p>4</p>
              </td>
              <td width="208">
                <p>&nbsp;</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>R1 ⋈ R2 with condition R1.regno &gt; R2.regno</p>
        <table width="624">
          <tbody>
            <tr>
              <td colspan="3" width="124">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="129">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="129">
                <p>&nbsp;</p>
              </td>
              <td width="6">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="107">
                <p>&nbsp;</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="108">
                <p><strong>RegNo</strong></p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="115">
                <p><strong>Branch</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
              <td width="120">
                <p><strong>Section</strong></p>
              </td>
              <td rowspan="2" width="6">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
              <td width="99">
                <p><strong>Name</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p><strong>Regno</strong></p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="108">
                <p>&nbsp;</p>
              </td>
              <td width="115">
                <p>&nbsp;</p>
              </td>
              <td width="120">
                <p>&nbsp;</p>
              </td>
              <td width="99">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="115">
                <p>3</p>
              </td>
              <td width="9">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="122">
                <p>CIVIL</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="129">
                <p>A</p>
              </td>
              <td width="6">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="107">
                <p>Bhanu</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>2</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="115">
                <p>4</p>
              </td>
              <td width="9">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="122">
                <p>IT</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="129">
                <p>B</p>
              </td>
              <td width="6">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="107">
                <p>Bhanu</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>2</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="115">
                <p>5</p>
              </td>
              <td width="9">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="122">
                <p>IT</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="129">
                <p>A</p>
              </td>
              <td width="6">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="107">
                <p>Bhanu</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>2</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="124">
                <p>5</p>
              </td>
              <td colspan="3" width="129">
                <p>IT</p>
              </td>
              <td colspan="3" width="135">
                <p>B</p>
              </td>
              <td colspan="3" width="115">
                <p>Priya</p>
              </td>
              <td colspan="3" width="121">
                <p>4</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>In the join operation, we select those rows from the cartesian product where R1.regno&gt;R2.regno.</p>
        <p>Join operation = select operation + cartesian product operation</p>
        <ol start="2">
          <li>Equi join:</li>
        </ol>
        <p>It is also known as an inner join. It is the most common join. It is based on matched data as per the equality condition. The equi join uses the comparison operator(=).</p>
        <p><strong>Example:</strong></p>
        <p><strong>CUSTOMER RELATION</strong></p>
        <table width="624">
          <tbody>
            <tr>
              <td width="364">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="260">
                <p><strong>NAME</strong></p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td rowspan="2" width="364">
                <p><strong>CLASS_ID</strong></p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td width="260">
                <p>&nbsp;</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td width="364">
                <p>1</p>
              </td>
              <td width="260">
                <p>John</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td width="364">
                <p>2</p>
              </td>
              <td width="260">
                <p>Harry</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td width="364">
                <p>3</p>
              </td>
              <td width="260">
                <p>Jackson</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
          </tbody>
        </table>
        <p><strong>PRODUCT</strong></p>
        <table width="624">
          <tbody>
            <tr>
              <td rowspan="2" width="401">
                <p><strong>PRODUCT_ID</strong></p>
              </td>
              <td width="223">
                <p>&nbsp;</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td rowspan="2" width="223">
                <p>&nbsp;<strong>CITY</strong></p>
                <p>&nbsp;</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td width="401">
                <p>&nbsp;</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td width="401">
                <p>1</p>
              </td>
              <td width="223">
                <p>Delhi</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td width="401">
                <p>2</p>
              </td>
              <td width="223">
                <p>Mumbai</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td width="401">
                <p>3</p>
              </td>
              <td width="223">
                <p>Noida</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
          </tbody>
        </table>
        <p><strong>Input:</strong></p>
        <ol>
          <li>CUSTOMER ⋈ PRODUCT <strong>Output:</strong></li>
        </ol>
        <table width="624">
          <tbody>
            <tr>
              <td width="168">
                <p><strong>CLASS_ID</strong></p>
              </td>
              <td colspan="3" width="456">
                <p><strong>NAME</strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>PRODUCT_ID</strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>CITY</strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <sub>&nbsp;</sub></p>
              </td>
            </tr>
            <tr>
              <td width="168">
                <p>&nbsp;</p>
              </td>
              <td width="121">
                <p>&nbsp;</p>
              </td>
              <td width="215">
                <p>&nbsp;</p>
              </td>
              <td width="120">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="168">
                <p>1</p>
              </td>
              <td width="121">
                <p>John</p>
              </td>
              <td width="215">
                <p>1</p>
              </td>
              <td width="120">
                <p>Delhi</p>
              </td>
            </tr>
            <tr>
              <td width="168">
                <p>2</p>
              </td>
              <td width="121">
                <p>Harry</p>
              </td>
              <td width="215">
                <p>2</p>
              </td>
              <td width="120">
                <p>Mumbai</p>
              </td>
            </tr>
            <tr>
              <td width="168">
                <p>3</p>
              </td>
              <td width="121">
                <p>Harry</p>
              </td>
              <td width="215">
                <p>3</p>
              </td>
              <td width="120">
                <p>Noida</p>
              </td>
            </tr>
          </tbody>
        </table>
        <h5>Natural join</h5>
        <p>If we join R1 and R2 on equal condition then it is called natural join or equi join.</p>
        <p>Generally, join is referred to as natural join.</p>
        <p>Natural join of R1 and R2 is &minus;</p>
        <p>{ we select those tuples from cartesian product where R1.regno=R2.regno}R1 ⋈ R2</p>
        <table width="624">
          <tbody>
            <tr>
              <td rowspan="2" width="8">
                <p>&nbsp;</p>
              </td>
              <td width="136">
                <p><strong>Regno</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="8">
                <p>&nbsp;</p>
              </td>
              <td width="147">
                <p><strong>Branch</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
              <td width="152">
                <p><strong>Section</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
              <td width="128">
                <p><strong>Name</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="136">
                <p>&nbsp;</p>
              </td>
              <td width="147">
                <p>&nbsp;</p>
              </td>
              <td width="152">
                <p>&nbsp;</p>
              </td>
              <td width="128">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="144">
                <p>2</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="154">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="161">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="144">
                <p>Bhanu</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="144">
                <p>4</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="154">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="161">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="144">
                <p>priya</p>
              </td>
            </tr>
          </tbody>
        </table>
        <h5>Outer join</h5>
        <p>It is an extension of natural join to deal with missing values of relation.</p>
        <p>Consider R1 and R2 shown below &minus;</p>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table R1<sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sub>&nbsp;</h5>
        <table width="706">
          <tbody>
            <tr>
              <td rowspan="2" width="8">
                <p>&nbsp;</p>
              </td>
              <td width="184">
                <p><strong>RegNo</strong></p>
              </td>
              <td rowspan="2" width="104">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="8">
                <p>&nbsp;</p>
              </td>
              <td width="72">
                <p>&nbsp;</p>
              </td>
              <td width="122">
                <p><strong>Branch</strong></p>
              </td>
              <td rowspan="2" width="8">
                <p>&nbsp;</p>
              </td>
              <td width="201">
                <p><strong>Section</strong></p>
              </td>
            </tr>
            <tr>
              <td width="184">
                <p>&nbsp;</p>
              </td>
              <td width="72">
                <p>&nbsp;</p>
              </td>
              <td width="122">
                <p>&nbsp;</p>
              </td>
              <td width="201">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="192">
                <p>1</p>
              </td>
              <td width="104">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="79">
                <p>CSE</p>
              </td>
              <td width="122">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="209">
                <p>A</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="192">
                <p>2</p>
              </td>
              <td width="104">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="79">
                <p>ECE</p>
              </td>
              <td width="122">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="209">
                <p>B</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="192">
                <p>3</p>
              </td>
              <td width="104">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="79">
                <p>CIVIL</p>
              </td>
              <td width="122">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="209">
                <p>A</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="192">
                <p>4</p>
              </td>
              <td width="104">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="79">
                <p>IT</p>
              </td>
              <td width="122">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="209">
                <p>B</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="192">
                <p>5</p>
              </td>
              <td width="104">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="79">
                <p>IT</p>
              </td>
              <td width="122">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="209">
                <p>A</p>
              </td>
            </tr>
          </tbody>
        </table>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table R2<sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sub>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</h5>
        <table width="706">
          <tbody>
            <tr>
              <td rowspan="2" width="8">
                <p>&nbsp;</p>
              </td>
              <td width="123">
                <p>&nbsp;</p>
              </td>
              <td width="165">
                <p><strong>Name</strong></p>
              </td>
              <td rowspan="2" width="105">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="96">
                <p>&nbsp;</p>
              </td>
              <td width="208">
                <p><strong>Regno</strong></p>
              </td>
            </tr>
            <tr>
              <td width="123">
                <p>&nbsp;</p>
              </td>
              <td width="165">
                <p>&nbsp;</p>
              </td>
              <td width="208">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="131">
                <p>Bhanu</p>
              </td>
              <td width="165">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p>&nbsp;</p>
              </td>
              <td width="96">
                <p>2</p>
              </td>
              <td width="208">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="131">
                <p>Priya</p>
              </td>
              <td colspan="2" width="270">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="304">
                <p>4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="4" width="401">
                <p>Hari &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</p>
              </td>
              <td colspan="2" width="304">
                <p>7 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>Outer join is of three types. These are explained below &minus;</p>
        <p>Left outer join</p>
        <p>It is denoted by R1 ⋈ R2.</p>
        <table width="624">
          <tbody>
            <tr>
              <td rowspan="3" width="124">
                <p><strong>RegNo</strong></p>
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="122">
                <p>&nbsp;</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="3" width="135">
                <p><strong>Section</strong></p>
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="107">
                <p>&nbsp;</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="115">
                <p><strong>Branch</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
              <td width="99">
                <p><strong>Name</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p><strong>Regno</strong></p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="115">
                <p>&nbsp;</p>
              </td>
              <td width="99">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>2</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>Bhanu</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>2</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>4</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>Priya</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>4</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>1</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>NULL</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>NULL</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>3</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>NULL</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>NULL</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>5</p>
              </td>
              <td colspan="3" width="129">
                <p>-</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>NULL</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>NULL</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>Here all the tuples of R1(left table) appear in output.</p>
        <p>The mismatching values of R2 are filled with NULL.</p>
        <p>Left outer join = natural join + mismatch / extra tuple of R1</p>
        <p>Right outer join</p>
        <p>It is denoted by R1 ⋈ R2</p>
        <p>Here all the tuples of R2(right table) appear in output. The mismatching values of R1 are filled with NULL.</p>
        <table width="624">
          <tbody>
            <tr>
              <td rowspan="3" width="124">
                <p><strong>RegNo</strong></p>
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="122">
                <p>&nbsp;</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="3" width="135">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="107">
                <p>&nbsp;</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="115">
                <p><strong>Branch</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
              <td width="99">
                <p><strong>Name</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p><strong>Regno</strong></p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="115">
                <p>&nbsp;</p>
              </td>
              <td width="99">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>2</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>Bhanu</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>2</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>4</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>Priya</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>4</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>NULL</p>
              </td>
              <td colspan="3" width="129">
                <p>NULL</p>
              </td>
              <td width="135">
                <p>NULL</p>
              </td>
              <td colspan="2" width="107">
                <p>Hari</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>7</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>Right outer join = natural join+ mismatch/extra tuple of R2.</p>
        <p>Full outer join</p>
        <p>It is denoted by R1 ⋈ R2.</p>
        <p>Full outer join=left outer join U right outer join.</p>
        <table width="624">
          <tbody>
            <tr>
              <td rowspan="3" width="124">
                <p><strong>RegNo</strong></p>
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="129">
                <p>&nbsp;</p>
              </td>
              <td rowspan="3" width="135">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="115">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="115">
                <p><strong>Branch</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
              <td width="99">
                <p><strong>Name</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p><strong>Regno</strong></p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="115">
                <p>&nbsp;</p>
              </td>
              <td width="99">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="122">
                <p>&nbsp;</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="107">
                <p>&nbsp;</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>2</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>Bhanu</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>2</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>4</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>Priya</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>4</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>1</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>NULL</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>NULL</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>3</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>NULL</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>NULL</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>5</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>NULL</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>NULL</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>NULL</p>
              </td>
              <td colspan="2" width="122">
                <p>NULL</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>NULL</p>
              </td>
              <td colspan="2" width="107">
                <p>Hari</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>7</p>
              </td>
            </tr>
          </tbody>
        </table>
        <h5>Example</h5>
        <p>Given below is the picture of full outer join &minus;</p>
        <h2>Evaluation of Expressions</h2>
        <p>SQL queries are decomposed into query blocks. One query block contains a single SELECT-FROM-WHERE expression, as well as GROUP BY and HAVING clause (if any).</p>
        <p>Nested queries are split into separate query blocks.</p>
        <h3>Example</h3>
        <p>Consider an example given below &minus;</p>
        <p>Select lastname, firstname from employee where salary&gt;(select max(salary) from employee where deptname =CSE ;</p>
        <p>C=(select max(salary) from employee where deptname=CSE); // inner block Select lastname, firstname from employee where salary&gt;c; //outer block Where C represents the result returned from the inner block.</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The relation algebra for the inner block is Ģmax(salary)</p>
        <p>(&sigma;dname=CSE(employee))</p>
        <p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relation &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; algebra &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outer &nbsp; blocks is &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &Pi;lastname, firstname(&sigma;salary&gt;c(employee))</p>
        <p>The query optimizer would then choose an execution or evaluation plan for each block.</p>
        <h3>Evaluation of relational algebra expressions</h3>
        <p>Materialized evaluation &minus; Evaluate one operation at a time. Evaluate the expression in a bottom-up manner and stores intermediate results to temporary files.</p>
        <p>Store the result of A ⋈ B in a temporary file. Store the result of C ⋈ D in a temporary file.</p>
        <p>Finally, join the results stored in temporary files.</p>
        <p>The overall cost=sum of costs of individual operations + cost of writing intermediate results to disk, cost of writing results to results to temporary files and reading them back is quite high.</p>
        <p>Pipelined evaluation &minus; Evaluate several operations simultaneously. Result of one operation is passed to the next operation. Evaluate the expression in a bottom-up manner and don&rsquo;t store intermediate results to temporary files.</p>
        <p>Don&rsquo;t store the result of A ⋈ B in a temporary file. Instead the result is passed directly for projection with C and so on.</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Transformation of Relational &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Expressions in DBMS</strong></p>
        <h3><strong>Introduction</strong></h3>
        <p>When a query is submitted to the database, it is responsibility of database to determine algorithm to evaluate the query. The DBMS has to decide a low cost algorithm to evaluate the query and then optimal path to evaluate the query.</p>
        <p>The query may be simple or complex. Depending on the cost it has to pick better execution path. This is called query optimization.</p>
        <p>There are various factors affecting the performance of the query like number of records in the table, number of blocks allocated to each table, number of records in each block, size of the record, duplicate records, height of B+ tree, constraints and indexes etc. Let us see how to select a better performing query.</p>
        <h3><strong>Transformation of Relational Expressions</strong></h3>
        <p>When a SQL query is submitted to DB, it can be evaluated in number of ways. For example, consider the below case: Above</p>
        <p>query selects the EMP_ID and DEPT_NAME from EMP and DEPT table for DEPT_ID = 10. But when it is given to the DBMS, it divides the query into tokens and sees how it can be put together so that performance will be better. This is the duty of query optimizer. But altering the order of tokens in the query should not change the result. In either way it should give same result. Order of records can change and are least important. This is called equivalent query. There is set of rules to put tokens in the query. This is called equivalence rule.</p>
        <p><strong>Above query can be broken down by the DBMS in either ways below :</strong></p>
        <ul>
          <li>Select the records of EMP with DEPT_ID = 10 first then join them with DEPT table to get all matching records of EMP and DEPT. Then select only the columns EMP_ID and DEPT_NAME to display the result.</li>
          <li>Select all matching records from EMP and DEPT, from which filter on DEPT_ID = 10 and select only EMP_ID and DEPT_NAME to display.</li>
        </ul>
        <p>Both the steps above are same irrespective of how it is performed. Hence both are called equivalent query. These are not written in SQL, but using relational algebra, graph or tree.</p>
        <p>&prod; EMP_ID, DEPT_NAME (&sigma; DEPT_ID = 10 (EMP &infin;DEPT))</p>
        <p>or</p>
        <p>&sigma; DEPT_ID = 10 (&prod; EMP_ID, DEPT_NAME, DEPT_ID (EMP &infin;DEPT)) </p>
        <p>&nbsp;</p>
        <p>Above relational algebra and tree shows how DBMS depicts the query inside it. But the cost of both of them may vary. This is because the number of records in each step changes depending on the join and filters we use, and the algorithms used to evaluate them. For example we may have huge number of records in second case tree above to filter. But in the first case we are filtering the record first; hence number of records to join would have been reduced. This makes lots of difference and query optimizer calculates this difference and selects the optimal tree for query evaluation.</p>
        <h4>Estimating Statistics of Expression results in DBMS</h4>
        <p>In order to determine ideal plan for evaluating the query, it checks various details about the tables that are stored in the data dictionary. These informations about tables are collected when a table is created and when various DDL / DML operations are performed on it. The optimizer checks data dictionary for :</p>
        <ul>
          <li>Total number of records in a table, nr. This will help to determine which table needs to be accessed first. Usually smaller <a href="https://tutorialcup.com/dbms/tables.htm">tables</a> are executed first to reduce the size of the intermediary tables. Hence it is one of the important factors to be checked.</li>
          <li>Total number of records in each block, fr. This will be useful in determining blocking factor and is required to determine if the table fits in the memory or not.</li>
          <li>Total number of blocks assigned to a table, br. This is also an important factor to calculate number of records that can be assigned to each block. Suppose we have 100 records in a table and total number of blocks are 20, then fr can be calculated as nr/b r = 100/20 = 5.</li>
          <li>Total length of the records in the table, l r. This is an important factor when the size of the records varies significantly between any two tables in the query. If the record length is fixed, there is no significant affect. But when a variable length records are involved in the query, average length or actual length needs to be used depending upon the type of operations.</li>
          <li>Number of unique values for a column, d Ar. This is useful when a query uses aggregation operation or projection. It will provide an estimate on distinct number of columns selected while projection. Number groups of records can be determined using this when Aggregation operation is used in the query. E.g.; SUM, MAX, MIN, COUNT etc.</li>
          <li>Levels of index, x. This data provides the information like whether the single level of index like primary key index, secondary key indexes are used or multi-level indexes like B+ tree index, mergesort index etc are used. These index levels will provide details about number of block access required to retrieve the data.</li>
          <li>Selection cardinality of a column, s A. This is the number of records present with same column value as A. This is calculated as nr/d Ar. i.e.; total number of records with distinct value of A. For example, suppose EMP table has 500 records and DEPT_ID has 5 distinct values. Then the selection cardinality of DEPT_ID in EMP table is 500/ 5 = 100. That means, on an average 100 employees are distributed among each department. This is helpful in determining average number of records that would satisfy selection criteria.</li>
          <li>There many other factors too like index type, data file type, sorting order, type of sorting etc.</li>
        </ul>
        <p><strong>Query Evaluation Plan :</strong></p>
        <p>It is nothing but a program for an abstract machine inside the DBMS. It is produced by the query optimizer. At times this can also be termed as access plan because DBMS decide&rsquo;s how to access the rows. Query evaluation plans are very much similar to relational algebra expressions in most of the systems.</p>
        <p>&nbsp;</p>
        <p><strong>Evaluation Plans. </strong></p>
        <p>In the context of database management systems (DBMS), an evaluation plan refers to the strategy or approach used to execute a database query or transaction efficiently. When you submit a query to a DBMS, the system needs to determine how to retrieve and process the requested data from the database. The evaluation plan outlines the steps and operations that the DBMS will take to accomplish this task.</p>
        <p>The evaluation plan is crucial for optimizing the performance of queries and ensuring that they are executed in the most efficient manner possible.</p>
        <p>The DBMS uses various techniques and algorithms to generate an evaluation plan based on factors such as the query structure, available indexes, statistics about the data, and system configuration.</p>
        <p>&nbsp;</p>
        <p>Here are some common elements or stages that may be part of an evaluation plan:</p>
        <p>&nbsp;</p>
        <p>Parsing and validation: The DBMS first checks the syntax and semantics of the query to ensure it is valid and can be executed.</p>
        <p>Query optimization: The DBMS analyzes the query and explores different strategies to generate an optimized evaluation plan. This involves considering factors such as index usage, join order, and selection of appropriate algorithms and data access methods.</p>
        <p>Cost estimation: The DBMS estimates the cost of executing different evaluation plans based on factors like data distribution, available resources, and system statistics. The goal is to choose the plan with the lowest cost in terms of time and resources.</p>
        <p>Plan selection: The DBMS selects the evaluation plan with the lowest estimated cost and proceeds with executing the query accordingly.</p>
        <p>Data retrieval and processing: The DBMS retrieves the required data from the underlying storage system, performs any necessary transformations or computations, and applies filtering, sorting, or aggregations as specified by the query.</p>
        <p>Result delivery: Once the data has been processed, the DBMS delivers the query results back to the user or application.</p>
        <p>By employing effective evaluation plans, DBMSs can significantly enhance query performance, reduce resource consumption, and provide faster responses to user queries.</p>
        <p><strong>Executing a Query Evaluation Plan :</strong></p>
        <p>In many relational algebra expressions it is very necessary to translate expression and also to annotate the translated relational algebra expression with the commands used for stating and evaluating operation. And immediately after translating the user query, the system uses the query program.</p>
        <p><strong>Characteristics of Query Evaluation Plan:</strong></p>
        <ul>
          <li>It can also be called the Query Questionnaire.</li>
          <li>Systems must create a query system to fully analyze the query.</li>
          <li>Annotations in the test program sometimes refer to the steps used to perform.</li>
          <li>Related algebra with annotations named Evaluation Primitives containing the instructions needed to evaluate the work.</li>
          <li>There is therefore nothing wrong with the fact that the questionnaire program describes a sequence of previous works that are very useful in questioning.</li>
          <li>The result of the query is generated by the query engine.</li>
        </ul>
        <p><strong>Optimization :</strong></p>
        <ul>
          <li>Since we know that there are different types of questions so the cost of testing will vary, one thing is that the user does not need to write his question correctly because the system does it automatically.</li>
          <li>If the website system produces an effective query program that leads to cost reduction then this type of activity is known as Quiz Development.</li>
          <li>Since all tasks are cost-effective in allocating memory the query caller should have a limited cost analysis for each task.</li>
          <li></li>
        </ul>
        <table width="624">
          <tbody>
            <tr>
              <td colspan="2" width="624">
                <p>epending on how you work with databases, materialized views might meandifferent things (or nothing) to you. This article is meant to provide a general</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>introduction to materialized views at a conceptual and practical level. The</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>information below is not specific to <a href="https://www.materialize.com/">Materialize</a><a href="https://www.materialize.com/">,</a> which is a</p>
                <p>Postgres-compatible streaming database that maintains materialized views.</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p><strong>What is a view?</strong></p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>Let&rsquo;s first define regular views, and build up to materialized views:</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>View definition:</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>A view is a derived relation defined in terms of base (stored) relations. A viewdefines a SQL transformation from a set of base tables to a derived table; this</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>transformation is typically recomputed every time the view is referenced.</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>You can think of a view as a saved query on your database. Future <sub>SELECT</sub></p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>queries can reference the view by name.</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p><strong>View Example</strong></p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>Imagine a database with two tables: <sub>users </sub>and <sub>purchases</sub>, here is the SQL</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>statement (in PostgreSQL syntax) we use to create a view that summarizes</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>user purchases:</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>sql</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p><u>copycode</u></p>
              </td>
            </tr>
            <tr>
              <td width="413">
                <p>CREATE VIEW user_purchase_summary AS SELECT</p>
              </td>
              <td rowspan="2" width="211">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="413">
                <p>&nbsp;</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>u.id as user_id,</p>
        <p>COUNT(*) as total_purchases,</p>
        <p>SUM(purchases.amount) as lifetime_value</p>
        <p>FROM users u</p>
        <p>JOIN purchases p ON p.user_id = u.id;</p>
        <p>FROM user_purchase_summary</p>
        <p>WHERE</p>
        <p>lifetime_value &gt; 500;</p>
        <p>&nbsp;</p>
        <table width="624">
          <tbody>
            <tr>
              <td width="624">
                <p>Every time the database gets a query referencing a view, it needs to first</p>
              </td>
            </tr>
            <tr>
              <td width="624">
                <p>compute the results of the view, and then compute the rest of the query usingthose results.</p>
              </td>
            </tr>
            <tr>
              <td width="624">
                <p>In almost all modern databases, you can also &ldquo;stack&rdquo; views: You can create a view that references another view.</p>
              </td>
            </tr>
            <tr>
              <td width="624">
                <p><strong>What is a materialized view?</strong></p>
              </td>
            </tr>
            <tr>
              <td width="624">
                <p>A materialized view takes the regular view described above and materializes it</p>
              </td>
            </tr>
            <tr>
              <td width="624">
                <p>by proactively computing the results and storing them in a &ldquo;virtual&rdquo; table.</p>
              </td>
            </tr>
            <tr>
              <td width="624">
                <p>Materialized View definition:</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>&nbsp;</p>
        <table width="624">
          <tbody>
            <tr>
              <td colspan="3" width="624">
                <p>A view can be &ldquo;materialized&rdquo; by storing the tuples of the view in the database. Index structures can be built on the materialized view. Consequently,database accesses to the materialized view can be much faster thanrecomputing the view. A materialized view is like a cache --- a copy of the data that can be accessed quickly.</p>
                <p>If a regular view is a saved query, a materialized view is a saved query plus its results stored as a table.</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>There are a few important implications of a view being &ldquo;materialized:&rdquo;</p>
              </td>
            </tr>
            <tr>
              <td width="24">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="600">
                <p>1.&nbsp; When referenced in a query, a materialized view doesn&rsquo;t need to be recomputed. &mdash; The results are stored, so querying materialized views</p>
                <p>tends to be faster.</p>
                <p>2.&nbsp; Because it&rsquo;s stored as if it were a table, indexes can be built on the columns of a materialized view.</p>
                <p>3.&nbsp; A new problem of &ldquo;view maintenance&rdquo; arises. &mdash; Once a view is</p>
              </td>
            </tr>
            <tr>
              <td width="24">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="600">
                <p>materialized, it is only accurate until the underlying base relations are modified. The process of updating a materialized view in response to these changes is called <em>view maintenance.</em></p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p><strong>Should materialized views update automatically?</strong></p>
                <p>In practice: It would seem there is no consensus. Some databases have</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>materialized views that must be manually refreshed. A few have implemented</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>automatic updates, albeit with long lists of limitations. <em>See the </em><a href="https://www.materialize.com/what-is-a-materialized-view#how-do-materialized-views-work-in-specific-databases"><em>table</em></a> <a href="https://www.materialize.com/what-is-a-materialized-view#how-do-materialized-views-work-in-specific-databases"><em>below</em></a> <em>for</em></p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p><em>more details.</em></p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>In principle: Materialized views should update automatically. A &ldquo;view&rdquo; implies an anchored perspective on changing inputs. Think back to how regular viewswork: results are constantly changing as the underlying data changes.</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>Materialization just implies that the transformation is done proactively.</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>In defining a materialized view, we have given the database all the information</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>necessary to continually maintain the results as underlying data changes.</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>Databases should keep materialized views updated by default, but this has sofar proven impossible to deliver on.</p>
                <p><strong>Materialized view example</strong></p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>Here is the <sub>user_purchase_summary </sub>view from before, turned into a</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>materialized view:</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>sql</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p><u>copycode</u></p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="538">
                <p>CREATE MATERIALIZED VIEW user_purchase_summary AS SELECT</p>
              </td>
              <td rowspan="2" width="86">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="538">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="24">&nbsp;</td>
              <td width="514">&nbsp;</td>
              <td width="86">&nbsp;</td>
            </tr>
          </tbody>
        </table>
        <p>u.id as user_id,</p>
        <p>C</p>
        <h1>Query Processing in DBMS</h1>
        <p>Query Processing is the activity performed in extracting data from the database. In query processing, it takes various steps for fetching the data from the database. The steps involved are:</p>
        <ol>
          <li>Parsing and translation</li>
          <li>Optimization</li>
          <li>Evaluation</li>
        </ol>
        <p>The query processing works in the following way:</p>
        <h2>Parsing and Translation</h2>
        <p>As query processing includes certain activities for data retrieval. Initially, the given user queries get translated in high-level database languages such as SQL. It gets translated into expressions that can be further used at the physical level of the file system. After this, the actual evaluation of the queries and a variety of query -optimizing transformations and takes place. Thus before processing a query, a computer system needs to translate the query into a human-readable and understandable language. Consequently, SQL or Structured Query Language is the best suitable choice for humans. But, it is not perfectly suitable for the internal representation of the query to the system. Relational algebra is well suited for the internal representation of a query. The translation process in query processing is similar to the parser of a query. When a user executes any query, for generating the internal form of the query, the parser in the system checks the syntax of the query, verifies the name of the relation in the database, the tuple, and finally the required attribute value. The parser creates a tree of the query, known as 'parse-tree.' Further, translate it into the form of relational algebra. With this, it evenly replaces all the use of the views when used in the query.</p>
        <p>Thus, we can understand the working of a query processing in the below-described diagram:</p>
        <p>&nbsp;</p>
        <p>Suppose a user executes a query. As we have learned that there are various methods of extracting the data from the database. In SQL, a user wants to fetch the records of the employees whose salary is greater than or equal to 10000. For doing this, the following query is undertaken:</p>
        <p><strong>select emp_name from Employee where salary&gt;10000;</strong></p>
        <p>Thus, to make the system understand the user query, it needs to be translated in the form of relational algebra. We can bring this query in the relational algebra form as:</p>
        <p>○ <strong>&sigma;</strong><strong>salary&gt;10000 </strong><strong>(&pi;</strong><strong>salary </strong><strong>(Employee))</strong></p>
        <p>○ <strong>&pi;</strong><strong>salary </strong><strong>(&sigma;</strong><strong>salary&gt;10000 </strong><strong>(Employee))</strong></p>
        <p>After translating the given query, we can execute each relational algebra operation by using different algorithms. So, in this way, a query processing begins its working.</p>
        <h2>Evaluation</h2>
        <p>For this, with addition to the relational algebra translation, it is required to annotate the translated relational algebra expression with the instructions used for specifying and evaluating each operation. Thus, after translating the user query, the system executes a query evaluation plan.</p>
        <h3>Query Evaluation Plan</h3>
        <p>○ In order to fully evaluate a query, the system needs to construct a query evaluation</p>
        <p>plan.</p>
        <p>○ The annotations in the evaluation plan may refer to the algorithms to be used for the particular index or the specific operations.</p>
        <p>○ Such relational algebra with annotations is referred to as <strong>Evaluation Primitives</strong>. The evaluation primitives carry the instructions needed for the evaluation of the</p>
        <p>operation.</p>
        <p>○ Thus, a query evaluation plan defines a sequence of primitive operations used for evaluating a query. The query evaluation plan is also referred to as <strong>the query </strong></p>
        <p><strong>execution plan</strong>.</p>
        <p>○ A <strong>query execution engine </strong>is responsible for generating the output of the given query. It takes the query execution plan, executes it, and finally makes the output for the user query.</p>
        <h2>Optimization</h2>
        <p>○ The cost of the query evaluation can vary for different types of queries. Although the system is responsible for constructing the evaluation plan, the user does need not to write their query efficiently.</p>
        <p>○ Usually, a database system generates an efficient query evaluation plan, which minimizes its cost. This type of task performed by the database system and is known as Query Optimization.</p>
        <p>○ For optimizing a query, the query optimizer should have an estimated cost analysis of each operation. It is because the overall operation cost depends on the memory allocations to several operations, execution costs, and so on.</p>
        <p>Finally, after selecting an evaluation plan, the system evaluates the query and produces the output of the query.</p>
        <h1>Estimating Query Cost</h1>
        <p>In the previous section, we understood about Query processing steps and evaluation plan. Though a system can create multiple plans for a query, the chosen method should be the best of all. It can be done by comparing each possible plan in terms of their estimated cost. For calculating the net estimated cost of any plan, the cost of each operation within a plan should be determined and combined to get the net estimated cost of the query evaluation plan.</p>
        <p>The cost estimation of a query evaluation plan is calculated in terms of various resources that include:</p>
        <p>○ Number of disk accesses</p>
        <p>○ Execution time taken by the CPU to execute a query</p>
        <p>○ Communication costs in distributed or parallel database systems.</p>
        <p>To estimate the cost of a query evaluation plan, we use the number of blocks transferred from the disk, and the number of disks seeks. Suppose the disk has an average block access time of t<sub>s </sub>seconds and takes an average of t<sub>T </sub>seconds to transfer x data blocks. The block access time is the sum of disk seeks time and rotational latency. It performs S seeks than the time taken will be <strong>b*t</strong><strong><sub>T </sub></strong><strong>+ S*t</strong><strong><sub>S </sub></strong>seconds. If t<sub>T</sub>=0.1 ms, t<sub>S </sub>=4 ms, the block size is 4 KB, and its transfer rate is 40 MB per second. With this, we can easily calculate the estimated cost of the given query evaluation plan.</p>
        <p>Generally, for estimating the cost, we consider the worst case that could happen. The users assume that initially, the data is read from the disk only. But there must be a chance that the information is already present in the main memory. However, the users usually ignore this effect, and due to this, the actual cost of execution comes out less than the estimated value.</p>
        <p>The response time, i.e., the time required to execute the plan, could be used for estimating the cost of the query evaluation plan. But due to the following reasons, it becomes difficult to calculate the response time without actually executing the query evaluation plan:</p>
        <p>○ When the query begins its execution, the response time becomes dependent on the contents stored in the buffer. But this information is difficult to retrieve when the query is in optimized mode, or it is not available also.</p>
        <p>○ When a system with multiple disks is present, the response time depends on an interrogation that in "what way accesses are distributed among the disks?". It is difficult to estimate without having detailed knowledge of the data layout present over the disk.</p>
        <p>○ Consequently, instead of minimizing the response time for any query evaluation plan, the optimizers finds it better to reduce the total <strong>resource consumption </strong>of the query plan. Thus to estimate the cost of a query evaluation plan, it is good to minimize the resources used for accessing the disk or use of the extra</p>
        <p>resources.</p>
        <h1>Selection Operation in Query Processing</h1>
        <p>In the previous section, we understood that estimating the cost of a query plan should be done by measuring the total resource consumption.</p>
        <p>In this section, we will understand how the selection operation is performed in the query execution plan.</p>
        <p>Generally, the selection operation is performed by the file scan. <strong>File scans </strong>are the search algorithms that are used for locating and accessing the data. It is the lowest-level operator used in query processing.</p>
        <p>Let's see how selection using a file scan is performed.</p>
        <h2>Selection using File scans and Indices</h2>
        <p>In RDBMS or relational database systems, the file scan reads a relation only if the whole relation is stored in one file only. When the selection operation is performed on a relation whose tuples are stored in one file, it uses the following algorithms:</p>
        <p>○ <strong>Linear Search: </strong>In a linear search, the system scans each record to test whether satisfying the given selection condition. For accessing the first block of a file, it needs an initial seek. If the blocks in the file are not stored in contiguous order, then it needs some extra seeks. However, linear search is the slowest algorithm used for searching, but it is applicable in all types of cases. This algorithm does not care about the nature of selection, availability of indices, or the file sequence.</p>
        <p>But other algorithms are not applicable in all types of cases.</p>
        <h2>Selection Operation with Indexes</h2>
        <p>The index-based search algorithms are known as <strong>Index scans</strong>. Such index structures are known as <strong>access paths</strong>. These paths allow locating and accessing the data in the file. There are following algorithms that use the index in query processing:</p>
        <p>○ <strong>Primary index, equality on a key: </strong>We use the index to retrieve a single record that satisfies the equality condition for making the selection. The equality comparison is performed on the key attribute carrying a primary key.</p>
        <p>○ <strong>Primary index, equality on nonkey: </strong>The difference between equality on key and nonkey is that in this, we can fetch multiple records. We can fetch multiple records through a primary key when the selection criteria specify the equality comparison on a nonkey.</p>
        <p>○ <strong>Secondary index, equality on key or nonkey: </strong>The selection that specifies an equality condition can use the secondary index. Using secondary index strategy, we can either retrieve a single record when equality is on key or multiple records when the equality condition is on nonkey. When retrieving a single record, the time cost is equal to the primary index. In the case of multiple records, they may reside on different blocks. This results in one I/O operation per fetched record, and each I/O operation requires a seek and a block transfer.</p>
        <h2>Selection Operations with Comparisons</h2>
        <p>For making any selection on the basis of a comparison in a relation, we can proceed it either by using the linear search or via indices in the following ways:</p>
        <p>○ <strong>Primary index, comparison: </strong>When the selection condition given by the user is a comparison, then we use a primary ordered index, such as the primary B<sup>+</sup>-tree index. <strong>For example</strong>, when A attribute of a relation R compared with a given value v as A&gt;v, then we use a primary index on A to directly retrieve the tuples. The file scan starts its search from the beginning till the end and outputs all those tuples that satisfy the given selection condition.</p>
        <p>○ <strong>Secondary index, comparison: </strong>The secondary ordered index is used for satisfying the selection operation that involves &lt;, &gt;, &le;, or &ge; In this, the files scan searches the blocks of the lowest-level index.</p>
        <p><strong>(&lt; &le;): </strong>In this case, it scans from the smallest value up to the given value v.</p>
        <p><strong>(&gt;, &ge;): </strong>In this case, it scans from the given value v up to the maximum value. However, the use of the secondary index should be limited for selecting a few records. It is because such an index provides pointers to point each record, so users can easily fetch the record through the allocated pointers. Such retrieved records may require an I/O operation as records may be stored on different blocks of the file. So, if the number of fetched records is large, it becomes expensive with the secondary index.</p>
        <h2>Implementing Complex Selection Operations</h2>
        <p>Working on more complex selection involves three selection predicates known as Conjunction, Disjunction, and Negation.</p>
        <p><strong>Conjunction: </strong>A conjunctive selection is the selection having the form as: <strong>&sigma; </strong></p>
        <p><strong>&theta;1 &theta;2 &hellip; &theta;n </strong><strong>(r)</strong></p>
        <p>A conjunction is the intersection of all records that satisfies the above selection condition.</p>
        <p><strong>Disjunction: </strong>A disjunctive selection is the selection having the form as: <strong>&sigma; </strong></p>
        <p><strong>&theta;1 &theta;2 &hellip; &theta;n </strong><strong>(r)</strong></p>
        <p>A disjunction is the union of all records that satisfies the given selection condition <strong>&theta;</strong><strong><sub>i</sub></strong>.</p>
        <p><strong>Negation: </strong>The result of a selection <strong>&sigma;</strong><strong><sub>&not;&theta;</sub></strong><strong>(r) </strong>is the set of tuples of given relation r where the selection condition evaluates to false. But nulls are not present, and this set is only the set of tuples in relation r that are not in <strong>&sigma;</strong><strong><sub>&theta;</sub></strong><strong>(r)</strong>.</p>
        <p>Using these discussed selection predicates, we can implement the selection operations by using the following algorithms:</p>
        <p>○ <strong>Conjunctive selection using one index: </strong>In such type of selection operation implementation, we initially determine if any access path is available for an attribute. If found one, then algorithms based on the index will work better. Further completion of the selection operation is done by testing that each selected records satisfy the remaining simple conditions. The cost of the selected algorithm provides the cost of this algorithm.</p>
        <p>○ <strong>Conjunctive selection via Composite index: </strong>A composite index is the one that is provided on multiple attributes. Such an index may be present for some conjunctive selections. If the given selection operation proves true on the equality condition on two or more attributes and a composite index is present on these combined attribute fields, then directly search the index. Such type of</p>
        <p>index evaluates the suitable index algorithms.</p>
        <p>○ <strong>Conjunctive selection via the intersection of identifiers: </strong>This implementation involves record pointers or record identifiers. It uses indices with the record pointers on those fields which are involved in the individual selection condition.</p>
        <p>It scans each index for pointers to tuples satisfying the individual condition. Therefore, the intersection of all the retrieved pointers is the set of pointers to the tuples that satisfies the conjunctive condition. The algorithm uses these pointers to fetch the actual records. However, in absence of indices on each individual condition, it tests the retrieved records for the other remaining</p>
        <p>conditions.</p>
        <p>○ <strong>Disjunctive selection by the union of identifiers: </strong>This algorithm scans those entire indexes for pointers to tuples that satisfy the individual condition. But only if access paths are available on all disjunctive selection conditions. Therefore, the union of all fetched records provides pointers sets to all those tuples which satisfy or prove the disjunctive condition. Further, it makes use of pointers for fetching the actual records. Somehow, if the access path is not present for anyone condition, we need to use a linear search to find those tuples that satisfy the condition. Thus, it is good to use a linear search for determining such tests.</p>
        <h1><strong>Sorting</strong></h1>
        <p>It is the technique of storing the records in ascending or descending order of one or more columns. It is useful because, some of the queries will ask us to return sorted records, or in operations like joins will be more efficient in sorted records. All the records are by default sorted based on the primary key column. In addition, we can specify to sort the records based on other columns, as required. Two types of sorting methods are mainly used.</p>
        <p>Internal Sorting:</p>
        <table width="600">
          <tbody>
            <tr>
              <td width="23">
                <p>&nbsp;</p>
              </td>
              <td width="577">
                <p>&nbsp; Internal sorting, also known as in-memory sorting, is performed when all the data to be sorted can fit entirely in memory. The sorting operation takes place within the main memory, which is faster compared to accessing data from disk.</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>In internal sorting, the DBMS loads the entire dataset into memory and applies sorting algorithms such as quicksort, mergesort, or heapsort. These algorithms rearrange the data in a specific order based on the sort criteria, such as ascending or descending order of a column. Once the sorting is complete, the sorted data is available for further</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>processing or retrieval.</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>Internal sorting is typically faster than external sorting because it avoids the overhead of reading and writing data to disk. However, it is limited by the available memory size.</p>
                <p>If</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>the dataset is too large to fit entirely in memory, external sorting techniques must be employed.</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>External Sorting:</p>
        <table width="600">
          <tbody>
            <tr>
              <td rowspan="3" width="23">
                <p>&nbsp;</p>
              </td>
              <td width="577">
                <p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; External sorting, also known as disk-based sorting, is used when the dataset is</p>
              </td>
            </tr>
            <tr>
              <td width="577">
                <p>too large to fit in memory. The sorting operation involves reading and writing data</p>
              </td>
            </tr>
            <tr>
              <td width="577">
                <p>to and from disk multiple times.</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>In external sorting, the DBMS divides the dataset into smaller parts, known as runs, that</p>
                <p>can fit in memory. Each run is sorted individually using internal sorting algorithms applied to the portion of the dataset residing in memory. The sorted runs are then merged together using techniques such as merge sort or replacement selection to</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>generate the final sorted result.</p>
                <p>The merging process involves reading a portion of each run into memory, comparing the</p>
                <p>records, and writing the sorted output to disk. This process continues until all runs have</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>been merged into a single sorted result.</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>External sorting is slower compared to internal sorting due to the disk I/O operations involved. However, it allows sorting large datasets that cannot be accommodated in</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>memory alone.</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>The choice between internal sorting and external sorting depends on the available</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="600">
                <p>memory size and the size of the dataset being sorted. DBMS optimizers consider these</p>
                <p>factors along with other statistics to determine the most efficient sorting strategy during query processing.</p>
              </td>
            </tr>
          </tbody>
        </table>
        <h2>External Sort-Merge Algorithm</h2>
        <p>Till now, we saw that sorting is an important term in any database system. It means arranging the data either in ascending or descending order. We use sorting not only for generating a sequenced output but also for satisfying conditions of various database algorithms. In query processing, the sorting method is used for performing various relational operations such as joins, etc. efficiently. But the need is to provide a sorted input value to the system. For sorting any relation, we have to build an index on the sort key and use that index for reading the relation in sorted order. However, using an index, we sort the relation logically, not physically. Thus, sorting is performed for cases that include:</p>
        <p><strong>Case 1: </strong>Relations that are having either small or medium size than main memory.</p>
        <p><strong>Case 2: </strong>Relations having a size larger than the memory size.</p>
        <p>In Case 1, the small or medium size relations do not exceed the size of the main memory. So, we can fit them in memory. So, we can use standard sorting methods such as quicksort, merge sort, etc., to do so.</p>
        <p>For Case 2, the standard algorithms do not work properly. Thus, for such relations whose size exceeds the memory size, we use the External Sort-Merge algorithm.</p>
        <p>The sorting of relations which do not fit in the memory because their size is larger than the memory size. Such type of sorting is known as <strong>External Sorting</strong>. As a result, the external-sort merge is the most suitable method used for external sorting.</p>
        <p>External Sort-Merge Algorithm</p>
        <p>Here, we will discuss the external-sort merge algorithm stages in detail:</p>
        <p>In the algorithm, M signifies the number of disk blocks available in the main memory buffer for sorting.</p>
        <p><strong>Stage 1: </strong>Initially, we create a number of sorted runs. Sort each of them. These runs contain only a few records of the relation.</p>
        <ol>
          <li>i = 0;</li>
          <li>repeat</li>
          <li><strong>read </strong>either M blocks or the rest <strong>of </strong>the relation <strong>having </strong>a smaller <strong>size</strong>;</li>
          <li>sort the in-memory part <strong>of </strong>the relation;</li>
          <li>write the sorted data <strong>to </strong>run file Ri;</li>
          <li>i =i+1;</li>
          <li>Until the <strong>end of </strong>the relation</li>
        </ol>
        <p>In Stage 1, we can see that we are performing the sorting operation on the disk blocks. After completing the steps of Stage 1, proceed to Stage 2.</p>
        <p><strong>Stage 2: </strong>In Stage 2, we merge the runs. Consider that total number of runs, i.e., N is less than M. So, we can allocate one block to each run and still have some space left to hold one block of output. We perform the operation as follows:</p>
        <ol>
          <li><strong>read </strong>one block <strong>of </strong>each <strong>of </strong>N files Ri <strong>into </strong>a buffer block in memory;</li>
          <li>repeat</li>
          <li><strong>select </strong>the <strong>first </strong>tuple among all buffer blocks (<strong>where </strong>selection <strong>is </strong>made</li>
        </ol>
        <p>in sorted <strong>order</strong>);</p>
        <ol start="4">
          <li>write the tuple <strong>to </strong>the <strong>output</strong>, and <strong>then delete </strong>it <strong>from </strong>the buffer block;</li>
          <li>if the buffer block <strong>of </strong>any run Ri <strong>is </strong>empty and not EOF(Ri)</li>
          <li><strong>then read </strong>the <strong>next </strong>block <strong>of </strong>Ri <strong>into </strong>the buffer block;</li>
          <li>Until all input buffer blocks are empty</li>
        </ol>
        <p>After completing Stage 2, we will get a sorted relation as an output. The output file is then buffered for minimizing the disk-write operations. As this algorithm merges N runs, that's why it is known as an <strong>N-way merge.</strong></p>
        <p>However, if the size of the relation is larger than the memory size, then either M or more runs will be generated in Stage 1. Also, it is not possible to allocate a single block for each run while processing Stage 2. In such a case, the merge operation process in multiple passes. As M-1 input buffer blocks have sufficient memory, each merge can easily hold M-1 runs as its input. So, the initial phase works in the following way:</p>
        <p>○ It merges the first M-1 runs for getting a single run for the next one.</p>
        <p>○ Similarly, it merges the next M-1 runs. This step continues until it processes all the initial runs. Here, the number of runs has a reduced M-1 value. Still, if this reduced value is greater than or equal to M, we need to create another pass. For this new pass, the input will be the runs created by the first pass.</p>
        <p>○ The work of each pass will be to reduce the number of runs by M-1 value. This job repeats as many times as needed until the number of runs is either less than or</p>
        <p>equal to M.</p>
        <p>○ Thus, a final pass produces the sorted output.</p>
        <h3>Example of External Merge-sort Algorithm</h3>
        <p>Let's understand the working of the external merge-sort algorithm and also analyze the cost of the external sorting with the help of an example.</p>
        <p>&nbsp;</p>
        <p>Suppose that for a relation R, we are performing the external sort-merge. In this, assume that only one block can hold one tuple, and the memory can hold at most three blocks. So, while processing Stage 2, i.e., the merge stage, it will use two blocks as input and one block for output.</p>
        <h3>Join</h3>
        <p>Join operation combines the relation R1 and R2 with respect to a condition. It is denoted by ⋈.</p>
        <p>The different types of join operation are as follows &minus;</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Theta join&nbsp;</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Equi join</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Natural join</p>
        <p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Outer join &minus; It is further classified into following types &minus; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Left outer join. &nbsp;</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Right outer join &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Full outer join.</p>
        <h4>Theta join</h4>
        <p>If we join R1 and R2 other than the equal to condition then it is called theta join/ nonequi join.</p>
        <h5>Example</h5>
        <p>Consider R1 table</p>
        <table width="694">
          <tbody>
            <tr>
              <td width="185">
                <p><strong>RegNo</strong></p>
              </td>
              <td rowspan="2" width="107">
                <p>&nbsp;</p>
              </td>
              <td width="195">
                <p><strong>Branch</strong></p>
              </td>
              <td width="74">
                <p>&nbsp;</p>
              </td>
              <td width="126">
                <p><strong>Section</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="185">
                <p>&nbsp;</p>
              </td>
              <td width="195">
                <p>&nbsp;</p>
              </td>
              <td width="74">
                <p>&nbsp;</p>
              </td>
              <td width="126">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="185">
                <p>1</p>
              </td>
              <td width="107">
                <p>&nbsp;</p>
              </td>
              <td width="195">
                <p>CSE</p>
              </td>
              <td width="74">
                <p>A</p>
              </td>
              <td colspan="2" width="134">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="185">
                <p>2</p>
              </td>
              <td width="107">
                <p>&nbsp;</p>
              </td>
              <td width="195">
                <p>ECE</p>
              </td>
              <td width="74">
                <p>B</p>
              </td>
              <td colspan="2" width="134">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="185">
                <p>3</p>
              </td>
              <td width="107">
                <p>&nbsp;</p>
              </td>
              <td width="195">
                <p>CIVIL</p>
              </td>
              <td width="74">
                <p>A</p>
              </td>
              <td colspan="2" width="134">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="185">
                <p>4</p>
              </td>
              <td width="107">
                <p>&nbsp;</p>
              </td>
              <td width="195">
                <p>IT</p>
              </td>
              <td width="74">
                <p>B</p>
              </td>
              <td colspan="2" width="134">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="292">
                <p>5</p>
              </td>
              <td width="195">
                <p>IT</p>
              </td>
              <td width="74">
                <p>A</p>
              </td>
              <td colspan="2" width="134">
                <p>&nbsp;</p>
              </td>
            </tr>
          </tbody>
        </table>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table R2<sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sub>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</h5>
        <table width="694">
          <tbody>
            <tr>
              <td rowspan="3" width="393">
                <p>&nbsp;</p>
              </td>
              <td rowspan="3" width="93">
                <p>&nbsp;</p>
              </td>
              <td width="208">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="208">
                <p><strong>RegNo</strong></p>
              </td>
            </tr>
            <tr>
              <td width="208">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="393">
                <p>Bhanu &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</p>
              </td>
              <td width="93">
                <p>2</p>
              </td>
              <td width="208">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="393">
                <p>Priya &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</p>
              </td>
              <td width="93">
                <p>4</p>
              </td>
              <td width="208">
                <p>&nbsp;</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>R1 ⋈ R2 with condition R1.regno &gt; R2.regno</p>
        <table width="624">
          <tbody>
            <tr>
              <td colspan="3" width="124">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="129">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="129">
                <p>&nbsp;</p>
              </td>
              <td width="6">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="107">
                <p>&nbsp;</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="108">
                <p><strong>RegNo</strong></p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="115">
                <p><strong>Branch</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
              <td width="120">
                <p><strong>Section</strong></p>
              </td>
              <td rowspan="2" width="6">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
              <td width="99">
                <p><strong>Name</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p><strong>Regno</strong></p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="108">
                <p>&nbsp;</p>
              </td>
              <td width="115">
                <p>&nbsp;</p>
              </td>
              <td width="120">
                <p>&nbsp;</p>
              </td>
              <td width="99">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="115">
                <p>3</p>
              </td>
              <td width="9">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="122">
                <p>CIVIL</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="129">
                <p>A</p>
              </td>
              <td width="6">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="107">
                <p>Bhanu</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>2</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="115">
                <p>4</p>
              </td>
              <td width="9">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="122">
                <p>IT</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="129">
                <p>B</p>
              </td>
              <td width="6">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="107">
                <p>Bhanu</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>2</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="115">
                <p>5</p>
              </td>
              <td width="9">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="122">
                <p>IT</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="129">
                <p>A</p>
              </td>
              <td width="6">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="107">
                <p>Bhanu</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>2</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="124">
                <p>5</p>
              </td>
              <td colspan="3" width="129">
                <p>IT</p>
              </td>
              <td colspan="3" width="135">
                <p>B</p>
              </td>
              <td colspan="3" width="115">
                <p>Priya</p>
              </td>
              <td colspan="3" width="121">
                <p>4</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>In the join operation, we select those rows from the cartesian product where R1.regno&gt;R2.regno.</p>
        <p>Join operation = select operation + cartesian product operation</p>
        <ol start="2">
          <li>Equi join:</li>
        </ol>
        <p>It is also known as an inner join. It is the most common join. It is based on matched data as per the equality condition. The equi join uses the comparison operator(=).</p>
        <p><strong>Example:</strong></p>
        <p><strong>CUSTOMER RELATION</strong></p>
        <table width="624">
          <tbody>
            <tr>
              <td width="364">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="260">
                <p><strong>NAME</strong></p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td rowspan="2" width="364">
                <p><strong>CLASS_ID</strong></p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td width="260">
                <p>&nbsp;</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td width="364">
                <p>1</p>
              </td>
              <td width="260">
                <p>John</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td width="364">
                <p>2</p>
              </td>
              <td width="260">
                <p>Harry</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td width="364">
                <p>3</p>
              </td>
              <td width="260">
                <p>Jackson</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
          </tbody>
        </table>
        <p><strong>PRODUCT</strong></p>
        <table width="624">
          <tbody>
            <tr>
              <td rowspan="2" width="401">
                <p><strong>PRODUCT_ID</strong></p>
              </td>
              <td width="223">
                <p>&nbsp;</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td rowspan="2" width="223">
                <p>&nbsp;<strong>CITY</strong></p>
                <p>&nbsp;</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td width="401">
                <p>&nbsp;</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td width="401">
                <p>1</p>
              </td>
              <td width="223">
                <p>Delhi</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td width="401">
                <p>2</p>
              </td>
              <td width="223">
                <p>Mumbai</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
            <tr>
              <td width="401">
                <p>3</p>
              </td>
              <td width="223">
                <p>Noida</p>
              </td>
              <td width="0">&nbsp;</td>
            </tr>
          </tbody>
        </table>
        <p><strong>Input:</strong></p>
        <ol>
          <li>CUSTOMER ⋈ PRODUCT <strong>Output:</strong></li>
        </ol>
        <table width="624">
          <tbody>
            <tr>
              <td width="168">
                <p><strong>CLASS_ID</strong></p>
              </td>
              <td colspan="3" width="456">
                <p><strong>NAME</strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>PRODUCT_ID</strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>CITY</strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <sub>&nbsp;</sub></p>
              </td>
            </tr>
            <tr>
              <td width="168">
                <p>&nbsp;</p>
              </td>
              <td width="121">
                <p>&nbsp;</p>
              </td>
              <td width="215">
                <p>&nbsp;</p>
              </td>
              <td width="120">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="168">
                <p>1</p>
              </td>
              <td width="121">
                <p>John</p>
              </td>
              <td width="215">
                <p>1</p>
              </td>
              <td width="120">
                <p>Delhi</p>
              </td>
            </tr>
            <tr>
              <td width="168">
                <p>2</p>
              </td>
              <td width="121">
                <p>Harry</p>
              </td>
              <td width="215">
                <p>2</p>
              </td>
              <td width="120">
                <p>Mumbai</p>
              </td>
            </tr>
            <tr>
              <td width="168">
                <p>3</p>
              </td>
              <td width="121">
                <p>Harry</p>
              </td>
              <td width="215">
                <p>3</p>
              </td>
              <td width="120">
                <p>Noida</p>
              </td>
            </tr>
          </tbody>
        </table>
        <h5>Natural join</h5>
        <p>If we join R1 and R2 on equal condition then it is called natural join or equi join.</p>
        <p>Generally, join is referred to as natural join.</p>
        <p>Natural join of R1 and R2 is &minus;</p>
        <p>{ we select those tuples from cartesian product where R1.regno=R2.regno}R1 ⋈ R2</p>
        <table width="624">
          <tbody>
            <tr>
              <td rowspan="2" width="8">
                <p>&nbsp;</p>
              </td>
              <td width="136">
                <p><strong>Regno</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="8">
                <p>&nbsp;</p>
              </td>
              <td width="147">
                <p><strong>Branch</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
              <td width="152">
                <p><strong>Section</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
              <td width="128">
                <p><strong>Name</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="136">
                <p>&nbsp;</p>
              </td>
              <td width="147">
                <p>&nbsp;</p>
              </td>
              <td width="152">
                <p>&nbsp;</p>
              </td>
              <td width="128">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="144">
                <p>2</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="154">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="161">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="144">
                <p>Bhanu</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="144">
                <p>4</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="154">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="161">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="144">
                <p>priya</p>
              </td>
            </tr>
          </tbody>
        </table>
        <h5>Outer join</h5>
        <p>It is an extension of natural join to deal with missing values of relation.</p>
        <p>Consider R1 and R2 shown below &minus;</p>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table R1<sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sub>&nbsp;</h5>
        <table width="706">
          <tbody>
            <tr>
              <td rowspan="2" width="8">
                <p>&nbsp;</p>
              </td>
              <td width="184">
                <p><strong>RegNo</strong></p>
              </td>
              <td rowspan="2" width="104">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="8">
                <p>&nbsp;</p>
              </td>
              <td width="72">
                <p>&nbsp;</p>
              </td>
              <td width="122">
                <p><strong>Branch</strong></p>
              </td>
              <td rowspan="2" width="8">
                <p>&nbsp;</p>
              </td>
              <td width="201">
                <p><strong>Section</strong></p>
              </td>
            </tr>
            <tr>
              <td width="184">
                <p>&nbsp;</p>
              </td>
              <td width="72">
                <p>&nbsp;</p>
              </td>
              <td width="122">
                <p>&nbsp;</p>
              </td>
              <td width="201">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="192">
                <p>1</p>
              </td>
              <td width="104">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="79">
                <p>CSE</p>
              </td>
              <td width="122">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="209">
                <p>A</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="192">
                <p>2</p>
              </td>
              <td width="104">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="79">
                <p>ECE</p>
              </td>
              <td width="122">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="209">
                <p>B</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="192">
                <p>3</p>
              </td>
              <td width="104">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="79">
                <p>CIVIL</p>
              </td>
              <td width="122">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="209">
                <p>A</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="192">
                <p>4</p>
              </td>
              <td width="104">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="79">
                <p>IT</p>
              </td>
              <td width="122">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="209">
                <p>B</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="192">
                <p>5</p>
              </td>
              <td width="104">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="79">
                <p>IT</p>
              </td>
              <td width="122">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="209">
                <p>A</p>
              </td>
            </tr>
          </tbody>
        </table>
        <h5>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table R2<sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sub>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</h5>
        <table width="706">
          <tbody>
            <tr>
              <td rowspan="2" width="8">
                <p>&nbsp;</p>
              </td>
              <td width="123">
                <p>&nbsp;</p>
              </td>
              <td width="165">
                <p><strong>Name</strong></p>
              </td>
              <td rowspan="2" width="105">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="96">
                <p>&nbsp;</p>
              </td>
              <td width="208">
                <p><strong>Regno</strong></p>
              </td>
            </tr>
            <tr>
              <td width="123">
                <p>&nbsp;</p>
              </td>
              <td width="165">
                <p>&nbsp;</p>
              </td>
              <td width="208">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="131">
                <p>Bhanu</p>
              </td>
              <td width="165">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p>&nbsp;</p>
              </td>
              <td width="96">
                <p>2</p>
              </td>
              <td width="208">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="131">
                <p>Priya</p>
              </td>
              <td colspan="2" width="270">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="304">
                <p>4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="4" width="401">
                <p>Hari &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</p>
              </td>
              <td colspan="2" width="304">
                <p>7 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>Outer join is of three types. These are explained below &minus;</p>
        <p>Left outer join</p>
        <p>It is denoted by R1 ⋈ R2.</p>
        <table width="624">
          <tbody>
            <tr>
              <td rowspan="3" width="124">
                <p><strong>RegNo</strong></p>
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="122">
                <p>&nbsp;</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="3" width="135">
                <p><strong>Section</strong></p>
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="107">
                <p>&nbsp;</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="115">
                <p><strong>Branch</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
              <td width="99">
                <p><strong>Name</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p><strong>Regno</strong></p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="115">
                <p>&nbsp;</p>
              </td>
              <td width="99">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>2</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>Bhanu</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>2</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>4</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>Priya</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>4</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>1</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>NULL</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>NULL</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>3</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>NULL</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>NULL</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>5</p>
              </td>
              <td colspan="3" width="129">
                <p>-</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>NULL</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>NULL</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>Here all the tuples of R1(left table) appear in output.</p>
        <p>The mismatching values of R2 are filled with NULL.</p>
        <p>Left outer join = natural join + mismatch / extra tuple of R1</p>
        <p>Right outer join</p>
        <p>It is denoted by R1 ⋈ R2</p>
        <p>Here all the tuples of R2(right table) appear in output. The mismatching values of R1 are filled with NULL.</p>
        <table width="624">
          <tbody>
            <tr>
              <td rowspan="3" width="124">
                <p><strong>RegNo</strong></p>
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="122">
                <p>&nbsp;</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="3" width="135">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="107">
                <p>&nbsp;</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="115">
                <p><strong>Branch</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
              <td width="99">
                <p><strong>Name</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p><strong>Regno</strong></p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="115">
                <p>&nbsp;</p>
              </td>
              <td width="99">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>2</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>Bhanu</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>2</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>4</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>Priya</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>4</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>NULL</p>
              </td>
              <td colspan="3" width="129">
                <p>NULL</p>
              </td>
              <td width="135">
                <p>NULL</p>
              </td>
              <td colspan="2" width="107">
                <p>Hari</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>7</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>Right outer join = natural join+ mismatch/extra tuple of R2.</p>
        <p>Full outer join</p>
        <p>It is denoted by R1 ⋈ R2.</p>
        <p>Full outer join=left outer join U right outer join.</p>
        <table width="624">
          <tbody>
            <tr>
              <td rowspan="3" width="124">
                <p><strong>RegNo</strong></p>
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="129">
                <p>&nbsp;</p>
              </td>
              <td rowspan="3" width="135">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="115">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="115">
                <p><strong>Branch</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
              <td width="99">
                <p><strong>Name</strong></p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td rowspan="2" width="7">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p><strong>Regno</strong></p>
              </td>
              <td rowspan="2" width="9">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="115">
                <p>&nbsp;</p>
              </td>
              <td width="99">
                <p>&nbsp;</p>
              </td>
              <td width="105">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="122">
                <p>&nbsp;</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="107">
                <p>&nbsp;</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>2</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>Bhanu</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>2</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>4</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>Priya</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>4</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>1</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>NULL</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>NULL</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>3</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>NULL</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>NULL</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>5</p>
              </td>
              <td colspan="2" width="122">
                <p>-</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>-</p>
              </td>
              <td colspan="2" width="107">
                <p>NULL</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>NULL</p>
              </td>
            </tr>
            <tr>
              <td width="124">
                <p>NULL</p>
              </td>
              <td colspan="2" width="122">
                <p>NULL</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td width="135">
                <p>NULL</p>
              </td>
              <td colspan="2" width="107">
                <p>Hari</p>
              </td>
              <td width="7">
                <p>&nbsp;</p>
              </td>
              <td colspan="3" width="121">
                <p>7</p>
              </td>
            </tr>
          </tbody>
        </table>
        <h5>Example</h5>
        <p>Given below is the picture of full outer join &minus;</p>
        <h2>Evaluation of Expressions</h2>
        <p>SQL queries are decomposed into query blocks. One query block contains a single SELECT-FROM-WHERE expression, as well as GROUP BY and HAVING clause (if any).</p>
        <p>Nested queries are split into separate query blocks.</p>
        <h3>Example</h3>
        <p>Consider an example given below &minus;</p>
        <p>Select lastname, firstname from employee where salary&gt;(select max(salary) from employee where deptname =CSE ;</p>
        <p>C=(select max(salary) from employee where deptname=CSE); // inner block Select lastname, firstname from employee where salary&gt;c; //outer block Where C represents the result returned from the inner block.</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The relation algebra for the inner block is Ģmax(salary)</p>
        <p>(&sigma;dname=CSE(employee))</p>
        <p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relation &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; algebra &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outer &nbsp; blocks is &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &Pi;lastname, firstname(&sigma;salary&gt;c(employee))</p>
        <p>The query optimizer would then choose an execution or evaluation plan for each block.</p>
        <h3>Evaluation of relational algebra expressions</h3>
        <p>Materialized evaluation &minus; Evaluate one operation at a time. Evaluate the expression in a bottom-up manner and stores intermediate results to temporary files.</p>
        <p>Store the result of A ⋈ B in a temporary file. Store the result of C ⋈ D in a temporary file.</p>
        <p>Finally, join the results stored in temporary files.</p>
        <p>The overall cost=sum of costs of individual operations + cost of writing intermediate results to disk, cost of writing results to results to temporary files and reading them back is quite high.</p>
        <p>Pipelined evaluation &minus; Evaluate several operations simultaneously. Result of one operation is passed to the next operation. Evaluate the expression in a bottom-up manner and don&rsquo;t store intermediate results to temporary files.</p>
        <p>Don&rsquo;t store the result of A ⋈ B in a temporary file. Instead the result is passed directly for projection with C and so on.</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Transformation of Relational &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Expressions in DBMS</strong></p>
        <h3><strong>Introduction</strong></h3>
        <p>When a query is submitted to the database, it is responsibility of database to determine algorithm to evaluate the query. The DBMS has to decide a low cost algorithm to evaluate the query and then optimal path to evaluate the query.</p>
        <p>The query may be simple or complex. Depending on the cost it has to pick better execution path. This is called query optimization.</p>
        <p>There are various factors affecting the performance of the query like number of records in the table, number of blocks allocated to each table, number of records in each block, size of the record, duplicate records, height of B+ tree, constraints and indexes etc. Let us see how to select a better performing query.</p>
        <h3><strong>Transformation of Relational Expressions</strong></h3>
        <p>When a SQL query is submitted to DB, it can be evaluated in number of ways. For example, consider the below case: Above</p>
        <p>query selects the EMP_ID and DEPT_NAME from EMP and DEPT table for DEPT_ID = 10. But when it is given to the DBMS, it divides the query into tokens and sees how it can be put together so that performance will be better. This is the duty of query optimizer. But altering the order of tokens in the query should not change the result. In either way it should give same result. Order of records can change and are least important. This is called equivalent query. There is set of rules to put tokens in the query. This is called equivalence rule.</p>
        <p><strong>Above query can be broken down by the DBMS in either ways below :</strong></p>
        <ul>
          <li>Select the records of EMP with DEPT_ID = 10 first then join them with DEPT table to get all matching records of EMP and DEPT. Then select only the columns EMP_ID and DEPT_NAME to display the result.</li>
          <li>Select all matching records from EMP and DEPT, from which filter on DEPT_ID = 10 and select only EMP_ID and DEPT_NAME to display.</li>
        </ul>
        <p>Both the steps above are same irrespective of how it is performed. Hence both are called equivalent query. These are not written in SQL, but using relational algebra, graph or tree.</p>
        <p>&prod; EMP_ID, DEPT_NAME (&sigma; DEPT_ID = 10 (EMP &infin;DEPT))</p>
        <p>or</p>
        <p>&sigma; DEPT_ID = 10 (&prod; EMP_ID, DEPT_NAME, DEPT_ID (EMP &infin;DEPT)) </p>
        <p>&nbsp;</p>
        <p>Above relational algebra and tree shows how DBMS depicts the query inside it. But the cost of both of them may vary. This is because the number of records in each step changes depending on the join and filters we use, and the algorithms used to evaluate them. For example we may have huge number of records in second case tree above to filter. But in the first case we are filtering the record first; hence number of records to join would have been reduced. This makes lots of difference and query optimizer calculates this difference and selects the optimal tree for query evaluation.</p>
        <h4>Estimating Statistics of Expression results in DBMS</h4>
        <p>In order to determine ideal plan for evaluating the query, it checks various details about the tables that are stored in the data dictionary. These informations about tables are collected when a table is created and when various DDL / DML operations are performed on it. The optimizer checks data dictionary for :</p>
        <ul>
          <li>Total number of records in a table, nr. This will help to determine which table needs to be accessed first. Usually smaller <a href="https://tutorialcup.com/dbms/tables.htm">tables</a> are executed first to reduce the size of the intermediary tables. Hence it is one of the important factors to be checked.</li>
          <li>Total number of records in each block, fr. This will be useful in determining blocking factor and is required to determine if the table fits in the memory or not.</li>
          <li>Total number of blocks assigned to a table, br. This is also an important factor to calculate number of records that can be assigned to each block. Suppose we have 100 records in a table and total number of blocks are 20, then fr can be calculated as nr/b r = 100/20 = 5.</li>
          <li>Total length of the records in the table, l r. This is an important factor when the size of the records varies significantly between any two tables in the query. If the record length is fixed, there is no significant affect. But when a variable length records are involved in the query, average length or actual length needs to be used depending upon the type of operations.</li>
          <li>Number of unique values for a column, d Ar. This is useful when a query uses aggregation operation or projection. It will provide an estimate on distinct number of columns selected while projection. Number groups of records can be determined using this when Aggregation operation is used in the query. E.g.; SUM, MAX, MIN, COUNT etc.</li>
          <li>Levels of index, x. This data provides the information like whether the single level of index like primary key index, secondary key indexes are used or multi-level indexes like B+ tree index, mergesort index etc are used. These index levels will provide details about number of block access required to retrieve the data.</li>
          <li>Selection cardinality of a column, s A. This is the number of records present with same column value as A. This is calculated as nr/d Ar. i.e.; total number of records with distinct value of A. For example, suppose EMP table has 500 records and DEPT_ID has 5 distinct values. Then the selection cardinality of DEPT_ID in EMP table is 500/ 5 = 100. That means, on an average 100 employees are distributed among each department. This is helpful in determining average number of records that would satisfy selection criteria.</li>
          <li>There many other factors too like index type, data file type, sorting order, type of sorting etc.</li>
        </ul>
        <p><strong>Query Evaluation Plan :</strong></p>
        <p>It is nothing but a program for an abstract machine inside the DBMS. It is produced by the query optimizer. At times this can also be termed as access plan because DBMS decide&rsquo;s how to access the rows. Query evaluation plans are very much similar to relational algebra expressions in most of the systems.</p>
        <p>&nbsp;</p>
        <p><strong>Evaluation Plans. </strong></p>
        <p>In the context of database management systems (DBMS), an evaluation plan refers to the strategy or approach used to execute a database query or transaction efficiently. When you submit a query to a DBMS, the system needs to determine how to retrieve and process the requested data from the database. The evaluation plan outlines the steps and operations that the DBMS will take to accomplish this task.</p>
        <p>The evaluation plan is crucial for optimizing the performance of queries and ensuring that they are executed in the most efficient manner possible.</p>
        <p>The DBMS uses various techniques and algorithms to generate an evaluation plan based on factors such as the query structure, available indexes, statistics about the data, and system configuration.</p>
        <p>&nbsp;</p>
        <p>Here are some common elements or stages that may be part of an evaluation plan:</p>
        <p>&nbsp;</p>
        <p>Parsing and validation: The DBMS first checks the syntax and semantics of the query to ensure it is valid and can be executed.</p>
        <p>Query optimization: The DBMS analyzes the query and explores different strategies to generate an optimized evaluation plan. This involves considering factors such as index usage, join order, and selection of appropriate algorithms and data access methods.</p>
        <p>Cost estimation: The DBMS estimates the cost of executing different evaluation plans based on factors like data distribution, available resources, and system statistics. The goal is to choose the plan with the lowest cost in terms of time and resources.</p>
        <p>Plan selection: The DBMS selects the evaluation plan with the lowest estimated cost and proceeds with executing the query accordingly.</p>
        <p>Data retrieval and processing: The DBMS retrieves the required data from the underlying storage system, performs any necessary transformations or computations, and applies filtering, sorting, or aggregations as specified by the query.</p>
        <p>Result delivery: Once the data has been processed, the DBMS delivers the query results back to the user or application.</p>
        <p>By employing effective evaluation plans, DBMSs can significantly enhance query performance, reduce resource consumption, and provide faster responses to user queries.</p>
        <p><strong>Executing a Query Evaluation Plan :</strong></p>
        <p>In many relational algebra expressions it is very necessary to translate expression and also to annotate the translated relational algebra expression with the commands used for stating and evaluating operation. And immediately after translating the user query, the system uses the query program.</p>
        <p><strong>Characteristics of Query Evaluation Plan:</strong></p>
        <ul>
          <li>It can also be called the Query Questionnaire.</li>
          <li>Systems must create a query system to fully analyze the query.</li>
          <li>Annotations in the test program sometimes refer to the steps used to perform.</li>
          <li>Related algebra with annotations named Evaluation Primitives containing the instructions needed to evaluate the work.</li>
          <li>There is therefore nothing wrong with the fact that the questionnaire program describes a sequence of previous works that are very useful in questioning.</li>
          <li>The result of the query is generated by the query engine.</li>
        </ul>
        <p><strong>Optimization :</strong></p>
        <ul>
          <li>Since we know that there are different types of questions so the cost of testing will vary, one thing is that the user does not need to write his question correctly because the system does it automatically.</li>
          <li>If the website system produces an effective query program that leads to cost reduction then this type of activity is known as Quiz Development.</li>
          <li>Since all tasks are cost-effective in allocating memory the query caller should have a limited cost analysis for each task.</li>
          <li></li>
        </ul>
        <table width="624">
          <tbody>
            <tr>
              <td colspan="2" width="624">
                <p>epending on how you work with databases, materialized views might meandifferent things (or nothing) to you. This article is meant to provide a general</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>introduction to materialized views at a conceptual and practical level. The</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>information below is not specific to <a href="https://www.materialize.com/">Materialize</a><a href="https://www.materialize.com/">,</a> which is a</p>
                <p>Postgres-compatible streaming database that maintains materialized views.</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p><strong>What is a view?</strong></p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>Let&rsquo;s first define regular views, and build up to materialized views:</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>View definition:</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>A view is a derived relation defined in terms of base (stored) relations. A viewdefines a SQL transformation from a set of base tables to a derived table; this</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>transformation is typically recomputed every time the view is referenced.</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>You can think of a view as a saved query on your database. Future <sub>SELECT</sub></p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>queries can reference the view by name.</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p><strong>View Example</strong></p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>Imagine a database with two tables: <sub>users </sub>and <sub>purchases</sub>, here is the SQL</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>statement (in PostgreSQL syntax) we use to create a view that summarizes</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>user purchases:</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p>sql</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="624">
                <p><u>copycode</u></p>
              </td>
            </tr>
            <tr>
              <td width="413">
                <p>CREATE VIEW user_purchase_summary AS SELECT</p>
              </td>
              <td rowspan="2" width="211">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="413">
                <p>&nbsp;</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>u.id as user_id,</p>
        <p>COUNT(*) as total_purchases,</p>
        <p>SUM(purchases.amount) as lifetime_value</p>
        <p>FROM users u</p>
        <p>JOIN purchases p ON p.user_id = u.id;</p>
        <p>FROM user_purchase_summary</p>
        <p>WHERE</p>
        <p>lifetime_value &gt; 500;</p>
        <p>&nbsp;</p>
        <table width="624">
          <tbody>
            <tr>
              <td width="624">
                <p>Every time the database gets a query referencing a view, it needs to first</p>
              </td>
            </tr>
            <tr>
              <td width="624">
                <p>compute the results of the view, and then compute the rest of the query usingthose results.</p>
              </td>
            </tr>
            <tr>
              <td width="624">
                <p>In almost all modern databases, you can also &ldquo;stack&rdquo; views: You can create a view that references another view.</p>
              </td>
            </tr>
            <tr>
              <td width="624">
                <p><strong>What is a materialized view?</strong></p>
              </td>
            </tr>
            <tr>
              <td width="624">
                <p>A materialized view takes the regular view described above and materializes it</p>
              </td>
            </tr>
            <tr>
              <td width="624">
                <p>by proactively computing the results and storing them in a &ldquo;virtual&rdquo; table.</p>
              </td>
            </tr>
            <tr>
              <td width="624">
                <p>Materialized View definition:</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>&nbsp;</p>
        <table width="624">
          <tbody>
            <tr>
              <td colspan="3" width="624">
                <p>A view can be &ldquo;materialized&rdquo; by storing the tuples of the view in the database. Index structures can be built on the materialized view. Consequently,database accesses to the materialized view can be much faster thanrecomputing the view. A materialized view is like a cache --- a copy of the data that can be accessed quickly.</p>
                <p>If a regular view is a saved query, a materialized view is a saved query plus its results stored as a table.</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>There are a few important implications of a view being &ldquo;materialized:&rdquo;</p>
              </td>
            </tr>
            <tr>
              <td width="24">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="600">
                <p>1.&nbsp; When referenced in a query, a materialized view doesn&rsquo;t need to be recomputed. &mdash; The results are stored, so querying materialized views</p>
                <p>tends to be faster.</p>
                <p>2.&nbsp; Because it&rsquo;s stored as if it were a table, indexes can be built on the columns of a materialized view.</p>
                <p>3.&nbsp; A new problem of &ldquo;view maintenance&rdquo; arises. &mdash; Once a view is</p>
              </td>
            </tr>
            <tr>
              <td width="24">
                <p>&nbsp;</p>
              </td>
              <td colspan="2" width="600">
                <p>materialized, it is only accurate until the underlying base relations are modified. The process of updating a materialized view in response to these changes is called <em>view maintenance.</em></p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p><strong>Should materialized views update automatically?</strong></p>
                <p>In practice: It would seem there is no consensus. Some databases have</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>materialized views that must be manually refreshed. A few have implemented</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>automatic updates, albeit with long lists of limitations. <em>See the </em><a href="https://www.materialize.com/what-is-a-materialized-view#how-do-materialized-views-work-in-specific-databases"><em>table</em></a> <a href="https://www.materialize.com/what-is-a-materialized-view#how-do-materialized-views-work-in-specific-databases"><em>below</em></a> <em>for</em></p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p><em>more details.</em></p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>In principle: Materialized views should update automatically. A &ldquo;view&rdquo; implies an anchored perspective on changing inputs. Think back to how regular viewswork: results are constantly changing as the underlying data changes.</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>Materialization just implies that the transformation is done proactively.</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>In defining a materialized view, we have given the database all the information</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>necessary to continually maintain the results as underlying data changes.</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>Databases should keep materialized views updated by default, but this has sofar proven impossible to deliver on.</p>
                <p><strong>Materialized view example</strong></p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>Here is the <sub>user_purchase_summary </sub>view from before, turned into a</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>materialized view:</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p>sql</p>
              </td>
            </tr>
            <tr>
              <td colspan="3" width="624">
                <p><u>copycode</u></p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="538">
                <p>CREATE MATERIALIZED VIEW user_purchase_summary AS SELECT</p>
              </td>
              <td rowspan="2" width="86">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td colspan="2" width="538">
                <p>&nbsp;</p>
              </td>
            </tr>
            <tr>
              <td width="24">&nbsp;</td>
              <td width="514">&nbsp;</td>
              <td width="86">&nbsp;</td>
            </tr>
          </tbody>
        </table>
        <p>u.id as user_id,</p>
        <p>COUNT(*) as total_purchases,</p>
        <p>SUM(CASE when p.status = 'cancelled' THEN 1 ELSE 0 END) as cancelled_purchases</p>
        <p>FROM users u</p>
        <p>JOIN purchases p ON p.user_id = u.id;</p>
        <p>&nbsp;</p>
        <table width="624">
          <tbody>
            <tr>
              <td colspan="2" width="624">
                <p>In terms of SQL, all that has changed is the addition of the <sub>MATERIALIZED</sub> keyword. But when executed, this statement instructs the database to:</p>
              </td>
            </tr>
            <tr>
              <td rowspan="2" width="24">
                <p>&nbsp;</p>
              </td>
              <td width="600">
                <p>1.&nbsp; Execute the SELECT query within the materialized view definition.</p>
                <p>2.&nbsp; Cache the results in a new &ldquo;virtual&rdquo; table named</p>
              </td>
            </tr>
            <tr>
              <td width="600">
                <p>user_purchase_summary</p>
                <p>3. Save the original query so it knows how to update the materialized viewin the future.</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>OUNT(*) as total_purchases,</p>
        <p>SUM(CASE when p.status = 'cancelled' THEN 1 ELSE 0 END) as cancelled_purchases</p>
        <p>FROM users u</p>
        <p>JOIN purchases p ON p.user_id = u.id;</p>
        <p>&nbsp;</p>
        <table width="624">
          <tbody>
            <tr>
              <td colspan="2" width="624">
                <p>In terms of SQL, all that has changed is the addition of the <sub>MATERIALIZED</sub> keyword. But when executed, this statement instructs the database to:</p>
              </td>
            </tr>
            <tr>
              <td rowspan="2" width="24">
                <p>&nbsp;</p>
              </td>
              <td width="600">
                <p>1.&nbsp; Execute the SELECT query within the materialized view definition.</p>
                <p>2.&nbsp; Cache the results in a new &ldquo;virtual&rdquo; table named</p>
              </td>
            </tr>
            <tr>
              <td width="600">
                <p>user_purchase_summary</p>
                <p>3. Save the original query so it knows how to update the materialized viewin the future.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>

    </div>
    <footer class="footer">
        <div class="container">
            <div class="row">
                <div class="footer-col">
                    <div class="webLogo">
                        <h2 class="logo">MCA_<span class="notes_text"> Notes</span></h2>
                    </div>
                </div>
                <div class="footer-col">
                    <h4>get help</h4>
                    <ul>
                        <li><a href="#">About US</a></li>
                        <li><a href="#">FAQ</a></li>
                        <li><a href="#">Privacy Policy</a></li>
                        <li><a href="#">Terms & Condition</a></li>

                    </ul>
                </div>
                <div class="footer-col">
                    <h4>All Link</h4>
                    <ul>
                        <li><a href="#">Home</a></li>
                        <li><a href="#">Contact US</a></li>
                        <li><a href="#">About Us</a></li>
                        <li><a href="#">Syllabus</a></li>
                        <li><a href="#">Quetion Paper</a></li>
                    </ul>
                </div>
                <div class="footer-col">
                    <h4>follow us</h4>
                    <div class="social-links">
                        <a href="#"><i class="fab fa-facebook-f"></i></a>
                        <a href="#"><i class="fab fa-twitter"></i></a>
                        <a href="#"><i class="fab fa-instagram"></i></a>
                        <a href="#"><i class="fab fa-linkedin-in"></i></a>
                    </div>
                </div>
                
            </div>
        </div>
        
    </footer>
    <script src="/gSap.js"></script>
    <script src="/script.js"></script>
</body>

</html>