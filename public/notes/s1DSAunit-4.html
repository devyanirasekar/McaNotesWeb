<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="notes.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <title>SEM1 DSA unit-4</title>
</head>
<body>
    
    <nav class="nav-container">
        <div class="text_logo">
            <h2 class="logo">MCA_<span class="notes_text"> Notes</span></h2>
        </div>

        <ul class="list">
            <a href="/index.html"><li class="listno list-diplay">Home</li></a>
            <li class="listno list-diplay">About</li>
            <li class="listno list-diplay">Contact</li>
            <li><span class="download list-diplay" id="download">Download</span></li>
            <li class="toggle"><i class="fa-solid fa-bars fa-lg toggle-btn"></i></li>
        </ul>

        
    </nav>
    <div class="dropDown">
        <ul class="drop-list">
            <a href="/index.html"><li class="listno ">Home</li></a>
            <li class="listno ">About</li>
            <li class="listno">Contact</li>
            <li><span class="download " id="download">Download</span></li></ul>
    </div>

    <!-- .................................................................... -->
    
    <div class="noteContainer">
    
    <!------------------------ paste code here   ---------------------------------- -->
    <div style="margin: 5px 0;">
        <p><strong>UNIT-4</strong></p>
        <p>&nbsp;</p>
        <div class="WaaZC Zh8Myb">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title">Searching and Sorting</h2>
              </div>
            </div>
            <div>&nbsp;</div>
          </div>
          <p>TWO ARRAY PROCESSING TECHNIQUES that are particularly common are searching and sorting. Searching here refers to finding an item in the array that meets some specified criterion. Sorting refers to rearranging all the items in the array into increasing or decreasing order (where the meaning of increasing and decreasing can depend on the context).</p>
          <p>Sorting and searching are often discussed, in a theoretical sort of way, using an array of numbers as an example. In practical situations, though, more interesting types of data are usually involved. For example, the array might be a mailing list, and each element of the array might be an object containing a name and address. Given the name of a person, you might want to look up that person's address. This is an example of searching, since you want to find the object in the array that contains the given name. It would also be useful to be able to sort the array according to various criteria. One example of sorting would be ordering the elements of the array so that the names are in alphabetical order. Another example would be to order the elements of the array according to zip code before printing a set of mailing labels. (This kind of sorting can get you a cheaper postage rate on a large mailing.)</p>
          <p>This example can be generalized to a more abstract situation in which we have an array that contains objects, and we want to search or sort the array based on the value of one of the instance variables in that array. We can use some terminology here that originated in work with "databases," which are just large, organized collections of data. We refer to each of the objects in the array as a record. The instance variables in an object are then called fields of the record. In the mailing list example, each record would contain a name and address. The fields of the record might be the first name, last name, street address, state, city and zip code. For the purpose of searching or sorting, one of the fields is designated to be the key field. Searching then means finding a record in the array that has a specified value in its key field. Sorting means moving the records around in the array so that the key fields of the record are in increasing (or decreasing) order.</p>
          <p>In this section, most of my examples follow the tradition of using arrays of numbers. But I'll also give a few examples using records and keys, to remind you of the more practical application.</p>
          <p><span style="font-family: aileron; font-size: 26px;">&nbsp;Searching</span></p>
          <div class="sect2" lang="en">
            <div class="titlepage">
              <div>&nbsp;</div>
            </div>
            <p>There is an obvious algorithm for searching for a particular item in an array: Look at each item in the array in turn, and check whether that item is the one you are looking for. If so, the search is finished. If you look at every item without finding the one you want, then you can be sure that the item is not in the array. It's easy to write a method to implement this algorithm. Let's say the array that you want to search is an array of ints. Here is a method that will search the array for a specified integer. If the integer is found, the method returns the index of the location in the array where it is found. If the integer is not in the array, the method returns the value -1 as a signal that the integer could not be found:</p>
            <pre class="programlisting">        static int find(int[] A, int N) {
                    // Searches the array A for the integer N.
                    // Postcondition:  If N is not in the array, -1 is
                    //     returned.  If N is in the array, then the
                    //     return value, i, is the first integer that
                    //     satisfies A[i] == N.
                    
                 for (int index = 0; index &lt; A.Length; index++) {
                    if ( A[index] == N ) 
                       return index;  // N has been found at this index!
                 }
                 
                 // If we get this far, then N has not been found
                 // anywhere in the array.  Return a value of -1.
      
                 return -1;
                 
              }
      </pre>
            <p>This method of searching an array by looking at each item in turn is called linear search. If nothing is known about the order of the items in the array, then there is really no better alternative algorithm. But if the elements in the array are known to be in increasing or decreasing order, then a much faster search algorithm can be used. An array in which the elements are in order is said to be sorted. Of course, it takes some work to sort an array, but if the array is to be searched many times, then the work done in sorting it can really pay off.</p>
            <p>Binary search is a method for searching for a given item in a sorted array. Although the implementation is not trivial, the basic idea is simple: If you are searching for an item in a sorted list, then it is possible to eliminate half of the items in the list by inspecting a single item. For example, suppose that you are looking for the number 42 in a sorted array of 1000 integers. Let's assume that the array is sorted into increasing order. Suppose you check item number 500 in the array, and find that the item is 93. Since 42 is less than 93, and since the elements in the array are in increasing order, we can conclude that if 42 occurs in the array at all, then it must occur somewhere before location 500. All the locations numbered 500 or above contain values that are greater than or equal to 93. These locations can be eliminated as possible locations of the number 42.</p>
            <p>The next obvious step is to check location 250. If the number at that location is, say, 21, then you can eliminate locations before 250 and limit further search to locations between 251 and 499. The next test will limit the search to about 125 locations, and the one after that to about 62. After just 10 steps, there is only one location left. This is a whole lot better than looking through every element in the array. If there were a million items, it would still take only 20 steps for this method to search the array! (Mathematically, the number of steps is the logarithm, in the base 2, of the number of items in the array.)</p>
            <p>In order to make binary search into a C# method that searches an array A for an item N, we just have to keep track of the range of locations that could possibly contain N. At each step, as we eliminate possibilities, we reduce the size of this range. The basic operation is to look at the item in the middle of the range. If this item is greater than N, then the second half of the range can be eliminated. If it is less than N, then the first half of the range can be eliminated. If the number in the middle just happens to be N exactly, then the search is finished. If the size of the range decreases to zero, then the number N does not occur in the array. Here is a method that returns the location of N in a sorted array A. If N cannot be found in the array, then a value of -1 is returned instead:</p>
            <pre class="programlisting">        static int binarySearch(int[] A, int N) {
                    // Searches the array A for the integer N.
                    // Precondition:  A must be sorted into increasing order.
                    // Postcondition:  If N is in the array, then the return
                    //    value, i, satisfies A[i] == N.  If not, then the
                    //    return value is -1.
                    
                  int lowestPossibleLoc = 0;
                  int highestPossibleLoc = A.Length - 1;
                  
                  while (highestPossibleLoc &gt;= lowestPossibleLoc) {
                     int middle = (lowestPossibleLoc + highestPossibleLoc) / 2;
                     if (A[middle] == N) {
                               // N has been found at this index!
                        return middle;
                     }
                     else if (A[middle] &gt; N) {
                               // eliminate locations &gt;= middle
                        highestPossibleLoc = middle - 1;
                     }
                     else {
                               // eliminate locations &lt;= middle
                        lowestPossibleLoc = middle + 1;   
                     }
                  }
                  
                  // At this point, highestPossibleLoc &lt; LowestPossibleLoc,
                  // which means that N is known to be not in the array.  Return
                  // a -1 to indicate that N could not be found in the array.
               
                  return -1;
      
              }<br /><br /><span style="font-family: aileron; font-size: 26px;">&nbsp;Insertion Sort</span>
      </pre>
          </div>
          <div class="sect2" lang="en">
            <div class="titlepage">
              <div>&nbsp;</div>
            </div>
            <p>We've seen that there are good reasons for sorting arrays. There are many algorithms available for doing so. One of the easiest to understand is the insertion sort algorithm. This method is also applicable to the problem of keeping a list in sorted order as you add new items to the list. Let's consider that case first:</p>
            <p>Suppose you have a sorted list and you want to add an item to that list. If you want to make sure that the modified list is still sorted, then the item must be inserted into the right location, with all the smaller items coming before it and all the bigger items after it. This will mean moving each of the bigger items up one space to make room for the new item.</p>
            <pre class="programlisting">     static void insert(int[] A, int itemsInArray, int newItem) {
                 // Precondition:  itemsInArray is the number of items that are
                 //    stored in A.  These items must be in increasing order
                 //    (A[0] &lt;= A[1] &lt;= ... &lt;= A[itemsInArray-1]).
                 //    The array size is at least one greater than itemsInArray.
                 // Postcondition:  The number of items has increased by one,
                 //    newItem has been added to the array, and all the items
                 //    in the array are still in increasing order.
                 // Note:  To complete the process of inserting an item in the
                 //    array, the variable that counts the number of items
                 //    in the array must be incremented, after calling this
                 //    method.
                 
              int loc = itemsInArray - 1;  // Start at the end of the array.
              
              /* Move items bigger than newItem up one space;
                 Stop when a smaller item is encountered or when the
                 beginning of the array (loc == 0) is reached. */
              
              while (loc &gt;= 0 &amp;&amp; A[loc] &gt; newItem) {
                 A[loc + 1] = A[loc];  // Bump item from A[loc] up to loc+1.
                 loc = loc - 1;        // Go on to next location.
              }
              
              A[loc + 1] = newItem;  // Put newItem in last vacated space.
      
           }
      </pre>
            <p>Conceptually, this could be extended to a sorting method if we were to take all the items out of an unsorted array, and then insert them back into the array one-by-one, keeping the list in sorted order as we do so. Each insertion can be done using the insert routine given above. In the actual algorithm, we don't really take all the items from the array; we just remember what part of the array has been sorted:</p>
            <pre class="programlisting">     static void insertionSort(int[] A) {
                 // Sort the array A into increasing order.
                 
              int itemsSorted; // Number of items that have been sorted so far.
      
              for (itemsSorted = 1; itemsSorted &lt; A.Length; itemsSorted++) {
                    // Assume that items A[0], A[1], ... A[itemsSorted-1] 
                    // have already been sorted.  Insert A[itemsSorted]
                    // into the sorted list.
                    
                 int temp = A[itemsSorted];  // The item to be inserted.
                 int loc = itemsSorted - 1;  // Start at end of list.
                 
                 while (loc &gt;= 0 &amp;&amp; A[loc] &gt; temp) {
                    A[loc + 1] = A[loc]; // Bump item from A[loc] up to loc+1.
                    loc = loc - 1;       // Go on to next location.
                 }
                 
                 A[loc + 1] = temp; // Put temp in last vacated space.
              }
           }
      </pre>
            <p>The following is an illustration of one stage in insertion sort. It shows what happens during one execution of the for loop in the above method, when itemsSorted is 5.</p>
            <div class="informalfigure">
              <div class="mediaobject"><img src="https://protect.bju.edu/cps/docs/cps110/textbook/images/c10_insertion_sort.gif" /></div>
            </div>
          </div>
          <div class="sect2" lang="en">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title">Selection Sort</h3>
                </div>
              </div>
              <div>&nbsp;</div>
            </div>
            <p>Another typical sorting method uses the idea of finding the biggest item in the list and moving it to the end -- which is where it belongs if the list is to be in increasing order. Once the biggest item is in its correct location, you can then apply the same idea to the remaining items. That is, find the next-biggest item, and move it into the next-to-last space, and so forth. This algorithm is called selection sort. It's easy to write:</p>
            <pre class="programlisting">     static void selectionSort(int[] A) {
      
                 // Sort A into increasing order, using selection sort
                 
              for (int lastPlace = A.Length-1; lastPlace &gt; 0; lastPlace--) {
                    // Find the largest item among A[0], A[1], ...,
                    // A[lastPlace], and move it into position lastPlace 
                    // by swapping it with the number that is currently 
                    // in position lastPlace.
                    
                 int maxLoc = 0;  // Location of largest item seen so far.
                 
                 for (int j = 1; j &lt;= lastPlace; j++) {
                    if (A[j] &gt; A[maxLoc]) {
                          // Since A[j] is bigger than the maximum we've seen
                          // so far, j is the new location of the maximum value
                          // we've seen so far.
                       maxLoc = j;  
                    }
                 }
                 
                 int temp = A[maxLoc];  // Swap largest item with A[lastPlace].
                 A[maxLoc] = A[lastPlace];
                 A[lastPlace] = temp;
                 
              }  // end of for loop
              
           }
      </pre>
            <p>Insertion sort and selection sort are suitable for sorting fairly small arrays (up to a few hundred elements, say). There are more complicated sorting algorithms that are much faster than insertion sort and selection sort for large arrays.</p>
          </div>
          <div class="sect2" lang="en">
            <div class="titlepage">
              <div>
                <div>
                  <h3 class="title"><a name="d0e6812"></a>&nbsp;Unsorting</h3>
                </div>
              </div>
              <div>&nbsp;</div>
            </div>
            <p>I can't resist ending this section on sorting with a related problem that is much less common, but is a bit more fun. That is the problem of putting the elements of an array into a random order. The typical case of this problem is shuffling a deck of cards. A good algorithm for shuffling is similar to selection sort, except that instead of moving the biggest item to the end of the list, an item is selected at random and moved to the end of the list. Here is a method to shuffle an array of ints:</p>
            <pre class="programlisting">     // Rearranges the items in &lt;A&gt; into a random order.
           static void shuffle(int[] A) {
      
              for (int lastPlace = A.Length-1; lastPlace &gt; 0; lastPlace--) {
                    // Choose a random location from among 0,1,...,lastPlace.
                 int randLoc = (int)(Math.random()*(lastPlace+1));
                    // Swap items in locations randLoc and lastPlace.
                 int temp = A[randLoc];
                 A[randLoc] = A[lastPlace];
                 A[lastPlace] = temp;
              }
           }
      </pre>
          </div>
        </div>
        <div class="WaaZC Zh8Myb">&nbsp;</div>
      </div>
    </div>
    <footer class="footer">
        <div class="container">
            <div class="row">
                <div class="footer-col">
                    <div class="webLogo">
                        <h2 class="logo">MCA_<span class="notes_text"> Notes</span></h2>
                    </div>
                </div>
                <div class="footer-col">
                    <h4>get help</h4>
                    <ul>
                        <li><a href="#">About US</a></li>
                        <li><a href="#">FAQ</a></li>
                        <li><a href="#">Privacy Policy</a></li>
                        <li><a href="#">Terms & Condition</a></li>

                    </ul>
                </div>
                <div class="footer-col">
                    <h4>All Link</h4>
                    <ul>
                        <li><a href="#">Home</a></li>
                        <li><a href="#">Contact US</a></li>
                        <li><a href="#">About Us</a></li>
                        <li><a href="#">Syllabus</a></li>
                        <li><a href="#">Quetion Paper</a></li>
                    </ul>
                </div>
                <div class="footer-col">
                    <h4>follow us</h4>
                    <div class="social-links">
                        <a href="#"><i class="fab fa-facebook-f"></i></a>
                        <a href="#"><i class="fab fa-twitter"></i></a>
                        <a href="#"><i class="fab fa-instagram"></i></a>
                        <a href="#"><i class="fab fa-linkedin-in"></i></a>
                    </div>
                </div>
                
            </div>
        </div>
        
    </footer>
    <script src="/gSap.js"></script>
    <script src="/script.js"></script>
</body>

</html>